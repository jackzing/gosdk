// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: peer.proto

package protos

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type PeerHandshakeResp_StatsCode int32

const (
	PeerHandshakeResp_PeerHsRetry      PeerHandshakeResp_StatsCode = 0
	PeerHandshakeResp_PeerHsNormal     PeerHandshakeResp_StatsCode = 1
	PeerHandshakeResp_PeerHsRecover    PeerHandshakeResp_StatsCode = 2
	PeerHandshakeResp_PeerHsUnexpected PeerHandshakeResp_StatsCode = 3
	PeerHandshakeResp_PeerHsRecoverQC  PeerHandshakeResp_StatsCode = 4
)

var PeerHandshakeResp_StatsCode_name = map[int32]string{
	0: "PeerHsRetry",
	1: "PeerHsNormal",
	2: "PeerHsRecover",
	3: "PeerHsUnexpected",
	4: "PeerHsRecoverQC",
}

var PeerHandshakeResp_StatsCode_value = map[string]int32{
	"PeerHsRetry":      0,
	"PeerHsNormal":     1,
	"PeerHsRecover":    2,
	"PeerHsUnexpected": 3,
	"PeerHsRecoverQC":  4,
}

func (x PeerHandshakeResp_StatsCode) String() string {
	return proto.EnumName(PeerHandshakeResp_StatsCode_name, int32(x))
}

func (PeerHandshakeResp_StatsCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{3, 0}
}

type PeerPing struct {
	View  uint64 `protobuf:"varint,1,opt,name=view,proto3" json:"view,omitempty"`
	MsgID uint64 `protobuf:"varint,2,opt,name=msgID,proto3" json:"msgID,omitempty"`
}

func (m *PeerPing) Reset()         { *m = PeerPing{} }
func (m *PeerPing) String() string { return proto.CompactTextString(m) }
func (*PeerPing) ProtoMessage()    {}
func (*PeerPing) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{0}
}
func (m *PeerPing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerPing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerPing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerPing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerPing.Merge(m, src)
}
func (m *PeerPing) XXX_Size() int {
	return m.Size()
}
func (m *PeerPing) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerPing.DiscardUnknown(m)
}

var xxx_messageInfo_PeerPing proto.InternalMessageInfo

func (m *PeerPing) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *PeerPing) GetMsgID() uint64 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

type PeerPong struct {
	View uint64 `protobuf:"varint,1,opt,name=view,proto3" json:"view,omitempty"`
}

func (m *PeerPong) Reset()         { *m = PeerPong{} }
func (m *PeerPong) String() string { return proto.CompactTextString(m) }
func (*PeerPong) ProtoMessage()    {}
func (*PeerPong) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{1}
}
func (m *PeerPong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerPong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerPong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerPong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerPong.Merge(m, src)
}
func (m *PeerPong) XXX_Size() int {
	return m.Size()
}
func (m *PeerPong) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerPong.DiscardUnknown(m)
}

var xxx_messageInfo_PeerPong proto.InternalMessageInfo

func (m *PeerPong) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

type PeerHandshake struct {
	Checkpoint *PeerCheckpoint   `protobuf:"bytes,1,opt,name=Checkpoint,proto3" json:"Checkpoint,omitempty"`
	Height     uint64            `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
	BlockHash  []byte            `protobuf:"bytes,3,opt,name=BlockHash,proto3" json:"BlockHash,omitempty"`
	View       uint64            `protobuf:"varint,4,opt,name=View,proto3" json:"View,omitempty"`
	Extra      []byte            `protobuf:"bytes,5,opt,name=extra,proto3" json:"extra,omitempty"`
	QC         *QuorumCheckpoint `protobuf:"bytes,6,opt,name=QC,proto3" json:"QC,omitempty"`
}

func (m *PeerHandshake) Reset()         { *m = PeerHandshake{} }
func (m *PeerHandshake) String() string { return proto.CompactTextString(m) }
func (*PeerHandshake) ProtoMessage()    {}
func (*PeerHandshake) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{2}
}
func (m *PeerHandshake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerHandshake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerHandshake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerHandshake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerHandshake.Merge(m, src)
}
func (m *PeerHandshake) XXX_Size() int {
	return m.Size()
}
func (m *PeerHandshake) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerHandshake.DiscardUnknown(m)
}

var xxx_messageInfo_PeerHandshake proto.InternalMessageInfo

func (m *PeerHandshake) GetCheckpoint() *PeerCheckpoint {
	if m != nil {
		return m.Checkpoint
	}
	return nil
}

func (m *PeerHandshake) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *PeerHandshake) GetBlockHash() []byte {
	if m != nil {
		return m.BlockHash
	}
	return nil
}

func (m *PeerHandshake) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *PeerHandshake) GetExtra() []byte {
	if m != nil {
		return m.Extra
	}
	return nil
}

func (m *PeerHandshake) GetQC() *QuorumCheckpoint {
	if m != nil {
		return m.QC
	}
	return nil
}

type PeerHandshakeResp struct {
	View        uint64                      `protobuf:"varint,1,opt,name=View,proto3" json:"View,omitempty"`
	MsgID       uint64                      `protobuf:"varint,2,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Code        PeerHandshakeResp_StatsCode `protobuf:"varint,3,opt,name=Code,proto3,enum=protos.PeerHandshakeResp_StatsCode" json:"Code,omitempty"`
	Extra       []byte                      `protobuf:"bytes,4,opt,name=extra,proto3" json:"extra,omitempty"`
	Checkpoints []*QuorumCheckpoint         `protobuf:"bytes,5,rep,name=checkpoints,proto3" json:"checkpoints,omitempty"`
}

func (m *PeerHandshakeResp) Reset()         { *m = PeerHandshakeResp{} }
func (m *PeerHandshakeResp) String() string { return proto.CompactTextString(m) }
func (*PeerHandshakeResp) ProtoMessage()    {}
func (*PeerHandshakeResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{3}
}
func (m *PeerHandshakeResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerHandshakeResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerHandshakeResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerHandshakeResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerHandshakeResp.Merge(m, src)
}
func (m *PeerHandshakeResp) XXX_Size() int {
	return m.Size()
}
func (m *PeerHandshakeResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerHandshakeResp.DiscardUnknown(m)
}

var xxx_messageInfo_PeerHandshakeResp proto.InternalMessageInfo

func (m *PeerHandshakeResp) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *PeerHandshakeResp) GetMsgID() uint64 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *PeerHandshakeResp) GetCode() PeerHandshakeResp_StatsCode {
	if m != nil {
		return m.Code
	}
	return PeerHandshakeResp_PeerHsRetry
}

func (m *PeerHandshakeResp) GetExtra() []byte {
	if m != nil {
		return m.Extra
	}
	return nil
}

func (m *PeerHandshakeResp) GetCheckpoints() []*QuorumCheckpoint {
	if m != nil {
		return m.Checkpoints
	}
	return nil
}

type PeerGenesis struct {
	MsgID            uint64     `protobuf:"varint,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Genesis          uint64     `protobuf:"varint,2,opt,name=genesis,proto3" json:"genesis,omitempty"`
	Epoch            *EpochInfo `protobuf:"bytes,3,opt,name=epoch,proto3" json:"epoch,omitempty"`
	SnapTxSum        uint64     `protobuf:"varint,4,opt,name=snapTxSum,proto3" json:"snapTxSum,omitempty"`
	FilterID         string     `protobuf:"bytes,5,opt,name=filterID,proto3" json:"filterID,omitempty"`
	Block            []byte     `protobuf:"bytes,6,opt,name=block,proto3" json:"block,omitempty"`
	Journal          []byte     `protobuf:"bytes,7,opt,name=journal,proto3" json:"journal,omitempty"`
	Receipt          []byte     `protobuf:"bytes,8,opt,name=receipt,proto3" json:"receipt,omitempty"`
	SnapInvalidTxSum uint64     `protobuf:"varint,9,opt,name=snapInvalidTxSum,proto3" json:"snapInvalidTxSum,omitempty"`
}

func (m *PeerGenesis) Reset()         { *m = PeerGenesis{} }
func (m *PeerGenesis) String() string { return proto.CompactTextString(m) }
func (*PeerGenesis) ProtoMessage()    {}
func (*PeerGenesis) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{4}
}
func (m *PeerGenesis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerGenesis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerGenesis.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerGenesis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerGenesis.Merge(m, src)
}
func (m *PeerGenesis) XXX_Size() int {
	return m.Size()
}
func (m *PeerGenesis) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerGenesis.DiscardUnknown(m)
}

var xxx_messageInfo_PeerGenesis proto.InternalMessageInfo

func (m *PeerGenesis) GetMsgID() uint64 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *PeerGenesis) GetGenesis() uint64 {
	if m != nil {
		return m.Genesis
	}
	return 0
}

func (m *PeerGenesis) GetEpoch() *EpochInfo {
	if m != nil {
		return m.Epoch
	}
	return nil
}

func (m *PeerGenesis) GetSnapTxSum() uint64 {
	if m != nil {
		return m.SnapTxSum
	}
	return 0
}

func (m *PeerGenesis) GetFilterID() string {
	if m != nil {
		return m.FilterID
	}
	return ""
}

func (m *PeerGenesis) GetBlock() []byte {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *PeerGenesis) GetJournal() []byte {
	if m != nil {
		return m.Journal
	}
	return nil
}

func (m *PeerGenesis) GetReceipt() []byte {
	if m != nil {
		return m.Receipt
	}
	return nil
}

func (m *PeerGenesis) GetSnapInvalidTxSum() uint64 {
	if m != nil {
		return m.SnapInvalidTxSum
	}
	return 0
}

type PeerLedgerPacket struct {
	MsgID    uint64 `protobuf:"varint,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	FilterID string `protobuf:"bytes,2,opt,name=FilterID,proto3" json:"FilterID,omitempty"`
	Last     bool   `protobuf:"varint,3,opt,name=Last,proto3" json:"Last,omitempty"`
	Payload  []byte `protobuf:"bytes,4,opt,name=Payload,proto3" json:"Payload,omitempty"`
	Extra    []byte `protobuf:"bytes,5,opt,name=Extra,proto3" json:"Extra,omitempty"`
}

func (m *PeerLedgerPacket) Reset()         { *m = PeerLedgerPacket{} }
func (m *PeerLedgerPacket) String() string { return proto.CompactTextString(m) }
func (*PeerLedgerPacket) ProtoMessage()    {}
func (*PeerLedgerPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{5}
}
func (m *PeerLedgerPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerLedgerPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerLedgerPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerLedgerPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerLedgerPacket.Merge(m, src)
}
func (m *PeerLedgerPacket) XXX_Size() int {
	return m.Size()
}
func (m *PeerLedgerPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerLedgerPacket.DiscardUnknown(m)
}

var xxx_messageInfo_PeerLedgerPacket proto.InternalMessageInfo

func (m *PeerLedgerPacket) GetMsgID() uint64 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *PeerLedgerPacket) GetFilterID() string {
	if m != nil {
		return m.FilterID
	}
	return ""
}

func (m *PeerLedgerPacket) GetLast() bool {
	if m != nil {
		return m.Last
	}
	return false
}

func (m *PeerLedgerPacket) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *PeerLedgerPacket) GetExtra() []byte {
	if m != nil {
		return m.Extra
	}
	return nil
}

type PeerLedgerPacketAck struct {
	MsgID   uint64          `protobuf:"varint,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Last    bool            `protobuf:"varint,2,opt,name=Last,proto3" json:"Last,omitempty"`
	Message *PeerAckMessage `protobuf:"bytes,3,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *PeerLedgerPacketAck) Reset()         { *m = PeerLedgerPacketAck{} }
func (m *PeerLedgerPacketAck) String() string { return proto.CompactTextString(m) }
func (*PeerLedgerPacketAck) ProtoMessage()    {}
func (*PeerLedgerPacketAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{6}
}
func (m *PeerLedgerPacketAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerLedgerPacketAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerLedgerPacketAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerLedgerPacketAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerLedgerPacketAck.Merge(m, src)
}
func (m *PeerLedgerPacketAck) XXX_Size() int {
	return m.Size()
}
func (m *PeerLedgerPacketAck) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerLedgerPacketAck.DiscardUnknown(m)
}

var xxx_messageInfo_PeerLedgerPacketAck proto.InternalMessageInfo

func (m *PeerLedgerPacketAck) GetMsgID() uint64 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *PeerLedgerPacketAck) GetLast() bool {
	if m != nil {
		return m.Last
	}
	return false
}

func (m *PeerLedgerPacketAck) GetMessage() *PeerAckMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

type PeerBlocks struct {
	MsgID      uint64   `protobuf:"varint,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Blocks     [][]byte `protobuf:"bytes,2,rep,name=blocks,proto3" json:"blocks,omitempty"`
	Journal    [][]byte `protobuf:"bytes,3,rep,name=journal,proto3" json:"journal,omitempty"`
	Receipts   [][]byte `protobuf:"bytes,4,rep,name=receipts,proto3" json:"receipts,omitempty"`
	StartBlock uint64   `protobuf:"varint,5,opt,name=StartBlock,proto3" json:"StartBlock,omitempty"`
	Extra      []byte   `protobuf:"bytes,6,opt,name=Extra,proto3" json:"Extra,omitempty"`
}

func (m *PeerBlocks) Reset()         { *m = PeerBlocks{} }
func (m *PeerBlocks) String() string { return proto.CompactTextString(m) }
func (*PeerBlocks) ProtoMessage()    {}
func (*PeerBlocks) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{7}
}
func (m *PeerBlocks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerBlocks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerBlocks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerBlocks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerBlocks.Merge(m, src)
}
func (m *PeerBlocks) XXX_Size() int {
	return m.Size()
}
func (m *PeerBlocks) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerBlocks.DiscardUnknown(m)
}

var xxx_messageInfo_PeerBlocks proto.InternalMessageInfo

func (m *PeerBlocks) GetMsgID() uint64 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *PeerBlocks) GetBlocks() [][]byte {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *PeerBlocks) GetJournal() [][]byte {
	if m != nil {
		return m.Journal
	}
	return nil
}

func (m *PeerBlocks) GetReceipts() [][]byte {
	if m != nil {
		return m.Receipts
	}
	return nil
}

func (m *PeerBlocks) GetStartBlock() uint64 {
	if m != nil {
		return m.StartBlock
	}
	return 0
}

func (m *PeerBlocks) GetExtra() []byte {
	if m != nil {
		return m.Extra
	}
	return nil
}

type PeerBlockAck struct {
	MsgID   uint64          `protobuf:"varint,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Message *PeerAckMessage `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Extra   []byte          `protobuf:"bytes,3,opt,name=Extra,proto3" json:"Extra,omitempty"`
}

func (m *PeerBlockAck) Reset()         { *m = PeerBlockAck{} }
func (m *PeerBlockAck) String() string { return proto.CompactTextString(m) }
func (*PeerBlockAck) ProtoMessage()    {}
func (*PeerBlockAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{8}
}
func (m *PeerBlockAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerBlockAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerBlockAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerBlockAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerBlockAck.Merge(m, src)
}
func (m *PeerBlockAck) XXX_Size() int {
	return m.Size()
}
func (m *PeerBlockAck) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerBlockAck.DiscardUnknown(m)
}

var xxx_messageInfo_PeerBlockAck proto.InternalMessageInfo

func (m *PeerBlockAck) GetMsgID() uint64 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *PeerBlockAck) GetMessage() *PeerAckMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *PeerBlockAck) GetExtra() []byte {
	if m != nil {
		return m.Extra
	}
	return nil
}

type PeerHpcBlockAck struct {
	MsgID   uint64          `protobuf:"varint,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Message *PeerAckMessage `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *PeerHpcBlockAck) Reset()         { *m = PeerHpcBlockAck{} }
func (m *PeerHpcBlockAck) String() string { return proto.CompactTextString(m) }
func (*PeerHpcBlockAck) ProtoMessage()    {}
func (*PeerHpcBlockAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{9}
}
func (m *PeerHpcBlockAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerHpcBlockAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerHpcBlockAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerHpcBlockAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerHpcBlockAck.Merge(m, src)
}
func (m *PeerHpcBlockAck) XXX_Size() int {
	return m.Size()
}
func (m *PeerHpcBlockAck) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerHpcBlockAck.DiscardUnknown(m)
}

var xxx_messageInfo_PeerHpcBlockAck proto.InternalMessageInfo

func (m *PeerHpcBlockAck) GetMsgID() uint64 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *PeerHpcBlockAck) GetMessage() *PeerAckMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

type PeerCheckpoint struct {
	Height uint64 `protobuf:"varint,1,opt,name=Height,proto3" json:"Height,omitempty"`
	Hash   []byte `protobuf:"bytes,2,opt,name=Hash,proto3" json:"Hash,omitempty"`
}

func (m *PeerCheckpoint) Reset()         { *m = PeerCheckpoint{} }
func (m *PeerCheckpoint) String() string { return proto.CompactTextString(m) }
func (*PeerCheckpoint) ProtoMessage()    {}
func (*PeerCheckpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{10}
}
func (m *PeerCheckpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerCheckpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerCheckpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerCheckpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerCheckpoint.Merge(m, src)
}
func (m *PeerCheckpoint) XXX_Size() int {
	return m.Size()
}
func (m *PeerCheckpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerCheckpoint.DiscardUnknown(m)
}

var xxx_messageInfo_PeerCheckpoint proto.InternalMessageInfo

func (m *PeerCheckpoint) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *PeerCheckpoint) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type PeerQuorumCheckpoint struct {
	MsgID       uint64              `protobuf:"varint,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Checkpoints []*QuorumCheckpoint `protobuf:"bytes,2,rep,name=checkpoints,proto3" json:"checkpoints,omitempty"`
}

func (m *PeerQuorumCheckpoint) Reset()         { *m = PeerQuorumCheckpoint{} }
func (m *PeerQuorumCheckpoint) String() string { return proto.CompactTextString(m) }
func (*PeerQuorumCheckpoint) ProtoMessage()    {}
func (*PeerQuorumCheckpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{11}
}
func (m *PeerQuorumCheckpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerQuorumCheckpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerQuorumCheckpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerQuorumCheckpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerQuorumCheckpoint.Merge(m, src)
}
func (m *PeerQuorumCheckpoint) XXX_Size() int {
	return m.Size()
}
func (m *PeerQuorumCheckpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerQuorumCheckpoint.DiscardUnknown(m)
}

var xxx_messageInfo_PeerQuorumCheckpoint proto.InternalMessageInfo

func (m *PeerQuorumCheckpoint) GetMsgID() uint64 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *PeerQuorumCheckpoint) GetCheckpoints() []*QuorumCheckpoint {
	if m != nil {
		return m.Checkpoints
	}
	return nil
}

type PeerQuorumCheckpointAck struct {
	MsgID   uint64          `protobuf:"varint,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Epoch   uint64          `protobuf:"varint,2,opt,name=Epoch,proto3" json:"Epoch,omitempty"`
	Message *PeerAckMessage `protobuf:"bytes,3,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *PeerQuorumCheckpointAck) Reset()         { *m = PeerQuorumCheckpointAck{} }
func (m *PeerQuorumCheckpointAck) String() string { return proto.CompactTextString(m) }
func (*PeerQuorumCheckpointAck) ProtoMessage()    {}
func (*PeerQuorumCheckpointAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{12}
}
func (m *PeerQuorumCheckpointAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerQuorumCheckpointAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerQuorumCheckpointAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerQuorumCheckpointAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerQuorumCheckpointAck.Merge(m, src)
}
func (m *PeerQuorumCheckpointAck) XXX_Size() int {
	return m.Size()
}
func (m *PeerQuorumCheckpointAck) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerQuorumCheckpointAck.DiscardUnknown(m)
}

var xxx_messageInfo_PeerQuorumCheckpointAck proto.InternalMessageInfo

func (m *PeerQuorumCheckpointAck) GetMsgID() uint64 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *PeerQuorumCheckpointAck) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *PeerQuorumCheckpointAck) GetMessage() *PeerAckMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

type PeerRollback struct {
	MsgID  uint64 `protobuf:"varint,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Height uint64 `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
}

func (m *PeerRollback) Reset()         { *m = PeerRollback{} }
func (m *PeerRollback) String() string { return proto.CompactTextString(m) }
func (*PeerRollback) ProtoMessage()    {}
func (*PeerRollback) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{13}
}
func (m *PeerRollback) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerRollback) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerRollback.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerRollback) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerRollback.Merge(m, src)
}
func (m *PeerRollback) XXX_Size() int {
	return m.Size()
}
func (m *PeerRollback) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerRollback.DiscardUnknown(m)
}

var xxx_messageInfo_PeerRollback proto.InternalMessageInfo

func (m *PeerRollback) GetMsgID() uint64 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *PeerRollback) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type PeerRollbackAck struct {
	MsgID   uint64          `protobuf:"varint,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Message *PeerAckMessage `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *PeerRollbackAck) Reset()         { *m = PeerRollbackAck{} }
func (m *PeerRollbackAck) String() string { return proto.CompactTextString(m) }
func (*PeerRollbackAck) ProtoMessage()    {}
func (*PeerRollbackAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{14}
}
func (m *PeerRollbackAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerRollbackAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerRollbackAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerRollbackAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerRollbackAck.Merge(m, src)
}
func (m *PeerRollbackAck) XXX_Size() int {
	return m.Size()
}
func (m *PeerRollbackAck) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerRollbackAck.DiscardUnknown(m)
}

var xxx_messageInfo_PeerRollbackAck proto.InternalMessageInfo

func (m *PeerRollbackAck) GetMsgID() uint64 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *PeerRollbackAck) GetMessage() *PeerAckMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

type PeerAckMessage struct {
	Ok  bool   `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *PeerAckMessage) Reset()         { *m = PeerAckMessage{} }
func (m *PeerAckMessage) String() string { return proto.CompactTextString(m) }
func (*PeerAckMessage) ProtoMessage()    {}
func (*PeerAckMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{15}
}
func (m *PeerAckMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerAckMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerAckMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerAckMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerAckMessage.Merge(m, src)
}
func (m *PeerAckMessage) XXX_Size() int {
	return m.Size()
}
func (m *PeerAckMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerAckMessage.DiscardUnknown(m)
}

var xxx_messageInfo_PeerAckMessage proto.InternalMessageInfo

func (m *PeerAckMessage) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *PeerAckMessage) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type PeerDisconnect struct {
}

func (m *PeerDisconnect) Reset()         { *m = PeerDisconnect{} }
func (m *PeerDisconnect) String() string { return proto.CompactTextString(m) }
func (*PeerDisconnect) ProtoMessage()    {}
func (*PeerDisconnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{16}
}
func (m *PeerDisconnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerDisconnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerDisconnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerDisconnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerDisconnect.Merge(m, src)
}
func (m *PeerDisconnect) XXX_Size() int {
	return m.Size()
}
func (m *PeerDisconnect) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerDisconnect.DiscardUnknown(m)
}

var xxx_messageInfo_PeerDisconnect proto.InternalMessageInfo

type PeerDisconnectAck struct {
}

func (m *PeerDisconnectAck) Reset()         { *m = PeerDisconnectAck{} }
func (m *PeerDisconnectAck) String() string { return proto.CompactTextString(m) }
func (*PeerDisconnectAck) ProtoMessage()    {}
func (*PeerDisconnectAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{17}
}
func (m *PeerDisconnectAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerDisconnectAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerDisconnectAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerDisconnectAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerDisconnectAck.Merge(m, src)
}
func (m *PeerDisconnectAck) XXX_Size() int {
	return m.Size()
}
func (m *PeerDisconnectAck) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerDisconnectAck.DiscardUnknown(m)
}

var xxx_messageInfo_PeerDisconnectAck proto.InternalMessageInfo

type Disconnect struct {
}

func (m *Disconnect) Reset()         { *m = Disconnect{} }
func (m *Disconnect) String() string { return proto.CompactTextString(m) }
func (*Disconnect) ProtoMessage()    {}
func (*Disconnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{18}
}
func (m *Disconnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Disconnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Disconnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Disconnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Disconnect.Merge(m, src)
}
func (m *Disconnect) XXX_Size() int {
	return m.Size()
}
func (m *Disconnect) XXX_DiscardUnknown() {
	xxx_messageInfo_Disconnect.DiscardUnknown(m)
}

var xxx_messageInfo_Disconnect proto.InternalMessageInfo

type DisconnectAck struct {
}

func (m *DisconnectAck) Reset()         { *m = DisconnectAck{} }
func (m *DisconnectAck) String() string { return proto.CompactTextString(m) }
func (*DisconnectAck) ProtoMessage()    {}
func (*DisconnectAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_055ae5a865fc1c9e, []int{19}
}
func (m *DisconnectAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DisconnectAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DisconnectAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DisconnectAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DisconnectAck.Merge(m, src)
}
func (m *DisconnectAck) XXX_Size() int {
	return m.Size()
}
func (m *DisconnectAck) XXX_DiscardUnknown() {
	xxx_messageInfo_DisconnectAck.DiscardUnknown(m)
}

var xxx_messageInfo_DisconnectAck proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("protos.PeerHandshakeResp_StatsCode", PeerHandshakeResp_StatsCode_name, PeerHandshakeResp_StatsCode_value)
	proto.RegisterType((*PeerPing)(nil), "protos.PeerPing")
	proto.RegisterType((*PeerPong)(nil), "protos.PeerPong")
	proto.RegisterType((*PeerHandshake)(nil), "protos.PeerHandshake")
	proto.RegisterType((*PeerHandshakeResp)(nil), "protos.PeerHandshakeResp")
	proto.RegisterType((*PeerGenesis)(nil), "protos.PeerGenesis")
	proto.RegisterType((*PeerLedgerPacket)(nil), "protos.PeerLedgerPacket")
	proto.RegisterType((*PeerLedgerPacketAck)(nil), "protos.PeerLedgerPacketAck")
	proto.RegisterType((*PeerBlocks)(nil), "protos.PeerBlocks")
	proto.RegisterType((*PeerBlockAck)(nil), "protos.PeerBlockAck")
	proto.RegisterType((*PeerHpcBlockAck)(nil), "protos.PeerHpcBlockAck")
	proto.RegisterType((*PeerCheckpoint)(nil), "protos.PeerCheckpoint")
	proto.RegisterType((*PeerQuorumCheckpoint)(nil), "protos.PeerQuorumCheckpoint")
	proto.RegisterType((*PeerQuorumCheckpointAck)(nil), "protos.PeerQuorumCheckpointAck")
	proto.RegisterType((*PeerRollback)(nil), "protos.PeerRollback")
	proto.RegisterType((*PeerRollbackAck)(nil), "protos.PeerRollbackAck")
	proto.RegisterType((*PeerAckMessage)(nil), "protos.PeerAckMessage")
	proto.RegisterType((*PeerDisconnect)(nil), "protos.PeerDisconnect")
	proto.RegisterType((*PeerDisconnectAck)(nil), "protos.PeerDisconnectAck")
	proto.RegisterType((*Disconnect)(nil), "protos.Disconnect")
	proto.RegisterType((*DisconnectAck)(nil), "protos.DisconnectAck")
}

func init() { proto.RegisterFile("peer.proto", fileDescriptor_055ae5a865fc1c9e) }

var fileDescriptor_055ae5a865fc1c9e = []byte{
	// 879 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcd, 0x6e, 0xe4, 0x44,
	0x10, 0x8e, 0x3d, 0xce, 0x64, 0x52, 0x99, 0x4d, 0x9c, 0x4e, 0x14, 0xac, 0x08, 0x8d, 0x22, 0x73,
	0x20, 0x42, 0xda, 0xcc, 0x2a, 0x20, 0x90, 0xd0, 0x5e, 0xb2, 0x93, 0x85, 0x04, 0xed, 0xa2, 0xa4,
	0x03, 0x2b, 0xc1, 0xad, 0xd3, 0xd3, 0x6b, 0x1b, 0x7b, 0xdc, 0xc6, 0xdd, 0x93, 0x4d, 0xde, 0x80,
	0x23, 0x27, 0x1e, 0x81, 0x47, 0xe0, 0x19, 0x38, 0x2e, 0x37, 0x8e, 0x28, 0x79, 0x11, 0xd4, 0x3f,
	0x1e, 0xf7, 0x84, 0x1d, 0xc4, 0xa2, 0x3d, 0x4d, 0x7f, 0x55, 0xd5, 0x5d, 0x5f, 0x7f, 0x55, 0x5d,
	0x63, 0x80, 0x8a, 0xb1, 0xfa, 0xa0, 0xaa, 0xb9, 0xe4, 0xa8, 0xab, 0x7f, 0xc4, 0xee, 0x51, 0x92,
	0xc9, 0x74, 0x7a, 0x79, 0x40, 0xf9, 0x64, 0x98, 0xde, 0x54, 0xac, 0xa6, 0x29, 0xc9, 0xca, 0x61,
	0xc2, 0x1f, 0xa6, 0x15, 0x7d, 0x48, 0xf9, 0x64, 0xc2, 0xcb, 0xa1, 0xbc, 0xa9, 0x98, 0x18, 0x9a,
	0x1d, 0x43, 0x9a, 0x32, 0x9a, 0x57, 0x3c, 0x2b, 0xa5, 0x39, 0x2a, 0xfe, 0x04, 0x7a, 0x67, 0x8c,
	0xd5, 0x67, 0x59, 0x99, 0x20, 0x04, 0xc1, 0x55, 0xc6, 0x5e, 0x45, 0xde, 0x9e, 0xb7, 0x1f, 0x60,
	0xbd, 0x46, 0xdb, 0xb0, 0x3c, 0x11, 0xc9, 0xe9, 0x71, 0xe4, 0x6b, 0xa3, 0x01, 0xf1, 0xc0, 0xee,
	0xe2, 0x6f, 0xde, 0x15, 0xff, 0xe1, 0xc1, 0x03, 0x15, 0x70, 0x42, 0xca, 0xb1, 0x48, 0x49, 0xce,
	0xd0, 0xa7, 0x00, 0xa3, 0x59, 0x6e, 0x1d, 0xbb, 0x76, 0xb8, 0x63, 0x38, 0x88, 0x03, 0x15, 0xda,
	0x7a, 0xb1, 0x13, 0x89, 0x76, 0xa0, 0x7b, 0xc2, 0xb2, 0x24, 0x95, 0x96, 0x80, 0x45, 0xe8, 0x7d,
	0x58, 0x7d, 0x52, 0x70, 0x9a, 0x9f, 0x10, 0x91, 0x46, 0x9d, 0x3d, 0x6f, 0xbf, 0x8f, 0x5b, 0x83,
	0xe2, 0xf4, 0x42, 0x71, 0x0a, 0x0c, 0xa7, 0x17, 0xf6, 0x26, 0xec, 0x5a, 0xd6, 0x24, 0x5a, 0xd6,
	0xd1, 0x06, 0xa0, 0x7d, 0xf0, 0xcf, 0x47, 0x51, 0x57, 0xf3, 0x89, 0x1a, 0x3e, 0xe7, 0x53, 0x5e,
	0x4f, 0x27, 0x0e, 0x23, 0xff, 0x7c, 0x14, 0xff, 0xe6, 0xc3, 0xe6, 0xdc, 0x9d, 0x30, 0x13, 0xd5,
	0x2c, 0x93, 0x37, 0x9f, 0xe9, 0xb9, 0xab, 0x99, 0x06, 0xe8, 0x33, 0x08, 0x46, 0x7c, 0xcc, 0x34,
	0xd9, 0xf5, 0xc3, 0x0f, 0xdc, 0xbb, 0xcf, 0x1d, 0x79, 0x70, 0x21, 0x89, 0x14, 0x2a, 0x14, 0xeb,
	0x0d, 0x2d, 0xf1, 0xc0, 0x25, 0xfe, 0x39, 0xac, 0xb5, 0xc5, 0x14, 0xd1, 0xf2, 0x5e, 0xe7, 0x5f,
	0x6f, 0xe0, 0x06, 0xc7, 0x05, 0xac, 0xce, 0x92, 0xa0, 0x0d, 0x58, 0xd3, 0x1c, 0x04, 0x66, 0xb2,
	0xbe, 0x09, 0x97, 0x50, 0x08, 0x7d, 0x63, 0xf8, 0x9a, 0xd7, 0x13, 0x52, 0x84, 0x1e, 0xda, 0xb4,
	0xd5, 0x14, 0x98, 0x51, 0x7e, 0xc5, 0xea, 0xd0, 0x47, 0xdb, 0x10, 0x1a, 0xd3, 0xb7, 0x25, 0xbb,
	0xae, 0x18, 0x95, 0x6c, 0x1c, 0x76, 0xd0, 0x16, 0x6c, 0xcc, 0x05, 0x9e, 0x8f, 0xc2, 0x20, 0xfe,
	0xc5, 0x37, 0x19, 0xbe, 0x64, 0x25, 0x13, 0x99, 0x68, 0xe5, 0xf1, 0x5c, 0x79, 0x22, 0x58, 0x49,
	0x4c, 0x80, 0x95, 0xad, 0x81, 0xe8, 0x43, 0x58, 0x66, 0x15, 0xa7, 0xa6, 0xcc, 0x6b, 0x87, 0x9b,
	0xcd, 0x1d, 0x9f, 0x2a, 0xe3, 0x69, 0xf9, 0x92, 0x63, 0xe3, 0x57, 0x3d, 0x21, 0x4a, 0x52, 0x7d,
	0x73, 0x7d, 0x31, 0x9d, 0xd8, 0xd2, 0xb7, 0x06, 0xb4, 0x0b, 0xbd, 0x97, 0x59, 0x21, 0x59, 0x7d,
	0x7a, 0xac, 0x5b, 0x60, 0x15, 0xcf, 0xb0, 0xa2, 0x74, 0xa9, 0x9a, 0x47, 0x37, 0x42, 0x1f, 0x1b,
	0xa0, 0x28, 0xfd, 0xc0, 0xa7, 0x75, 0x49, 0x8a, 0x68, 0x45, 0xdb, 0x1b, 0xa8, 0x3c, 0x35, 0xa3,
	0x2c, 0xab, 0x64, 0xd4, 0x33, 0x1e, 0x0b, 0xd1, 0x47, 0x10, 0xaa, 0x94, 0xa7, 0xe5, 0x15, 0x29,
	0xb2, 0xb1, 0xa1, 0xb2, 0xaa, 0xa9, 0xfc, 0xc3, 0x1e, 0xff, 0xe4, 0x19, 0x11, 0x9f, 0xb1, 0x71,
	0xc2, 0xea, 0x33, 0x42, 0x73, 0x26, 0x17, 0xa8, 0xb3, 0x0b, 0xbd, 0x2f, 0x1a, 0xf2, 0xbe, 0x21,
	0xdf, 0x60, 0xd5, 0x82, 0xcf, 0x88, 0x90, 0x5a, 0x9e, 0x1e, 0xd6, 0x6b, 0x45, 0xf0, 0x8c, 0xdc,
	0x14, 0x9c, 0x8c, 0x6d, 0xd7, 0x34, 0x50, 0x9d, 0xff, 0xd4, 0x7d, 0x06, 0x1a, 0xc4, 0x3f, 0xc2,
	0xd6, 0x7d, 0x26, 0x47, 0x34, 0x5f, 0x40, 0xa6, 0x49, 0xe8, 0x3b, 0x09, 0x1f, 0xc1, 0xca, 0x73,
	0x26, 0x04, 0x49, 0x98, 0x2d, 0xd3, 0xdc, 0xe3, 0x3e, 0xa2, 0xb9, 0xf5, 0xe2, 0x26, 0x2c, 0xfe,
	0xd5, 0x03, 0x50, 0x3e, 0xfd, 0x6a, 0x17, 0x75, 0xc5, 0x0e, 0x74, 0x75, 0x2d, 0x54, 0x53, 0x74,
	0xf6, 0xfb, 0xd8, 0x22, 0xb7, 0x34, 0x1d, 0xed, 0x98, 0x95, 0x66, 0x17, 0x7a, 0xb6, 0x16, 0x22,
	0x0a, 0xb4, 0x6b, 0x86, 0xd1, 0x00, 0xe0, 0x42, 0x92, 0x5a, 0xea, 0x94, 0x5a, 0x80, 0x00, 0x3b,
	0x96, 0x56, 0x9b, 0xae, 0xab, 0x4d, 0x61, 0xde, 0x83, 0x0e, 0x59, 0x2c, 0x8a, 0x23, 0x80, 0xff,
	0x9f, 0x04, 0x68, 0xb3, 0x75, 0xdc, 0x6c, 0xdf, 0xd9, 0x27, 0x54, 0xd1, 0x77, 0x9d, 0x30, 0x7e,
	0x0c, 0xeb, 0xf3, 0x93, 0xd6, 0x99, 0xae, 0xde, 0xdc, 0x74, 0x45, 0x10, 0xe8, 0xc1, 0xea, 0x6b,
	0x66, 0x7a, 0x1d, 0xa7, 0xb0, 0xad, 0x76, 0xdf, 0x9f, 0x2c, 0x0b, 0xd8, 0xdd, 0x1b, 0x4f, 0xfe,
	0xdb, 0x8c, 0xa7, 0x57, 0xf0, 0xde, 0x9b, 0x32, 0x2d, 0x96, 0x42, 0x29, 0xa9, 0x27, 0x84, 0x1d,
	0xb8, 0x1a, 0xfc, 0x8f, 0x96, 0x7c, 0x6c, 0x2a, 0x8d, 0x79, 0x51, 0x5c, 0x92, 0x85, 0xd9, 0x16,
	0xfc, 0x25, 0x35, 0x95, 0x6b, 0x76, 0xbf, 0xcb, 0xca, 0x1d, 0x9a, 0xca, 0xb5, 0x2e, 0xb4, 0x0e,
	0x3e, 0xcf, 0xf5, 0xb1, 0x3d, 0xec, 0xf3, 0x1c, 0x85, 0xd0, 0x99, 0x88, 0xc4, 0xce, 0x06, 0xb5,
	0x8c, 0x43, 0xb3, 0xe7, 0x38, 0x13, 0x94, 0x97, 0x25, 0xa3, 0x32, 0xde, 0x32, 0x7f, 0x60, 0xad,
	0xe5, 0x88, 0xe6, 0x71, 0x1f, 0xc0, 0x09, 0xd9, 0x80, 0x07, 0x73, 0xee, 0x27, 0x5f, 0xfd, 0x7e,
	0x3b, 0xf0, 0x5e, 0xdf, 0x0e, 0xbc, 0xbf, 0x6e, 0x07, 0xde, 0xcf, 0x77, 0x83, 0xa5, 0xd7, 0x77,
	0x83, 0xa5, 0x3f, 0xef, 0x06, 0x4b, 0xdf, 0x3f, 0x7a, 0xdb, 0x8f, 0x8f, 0x4b, 0xf3, 0xd9, 0xf2,
	0xf1, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x74, 0x9f, 0x54, 0x29, 0xcb, 0x08, 0x00, 0x00,
}

func (m *PeerPing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerPing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerPing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MsgID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MsgID))
		i--
		dAtA[i] = 0x10
	}
	if m.View != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerPong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerPong) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerPong) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.View != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerHandshake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerHandshake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerHandshake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QC != nil {
		{
			size, err := m.QC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPeer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Extra) > 0 {
		i -= len(m.Extra)
		copy(dAtA[i:], m.Extra)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Extra)))
		i--
		dAtA[i] = 0x2a
	}
	if m.View != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x20
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Height != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Checkpoint != nil {
		{
			size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPeer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PeerHandshakeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerHandshakeResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerHandshakeResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Checkpoints) > 0 {
		for iNdEx := len(m.Checkpoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Checkpoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPeer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Extra) > 0 {
		i -= len(m.Extra)
		copy(dAtA[i:], m.Extra)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Extra)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if m.MsgID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MsgID))
		i--
		dAtA[i] = 0x10
	}
	if m.View != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerGenesis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerGenesis) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerGenesis) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SnapInvalidTxSum != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.SnapInvalidTxSum))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Receipt) > 0 {
		i -= len(m.Receipt)
		copy(dAtA[i:], m.Receipt)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Receipt)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Journal) > 0 {
		i -= len(m.Journal)
		copy(dAtA[i:], m.Journal)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Journal)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Block) > 0 {
		i -= len(m.Block)
		copy(dAtA[i:], m.Block)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Block)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FilterID) > 0 {
		i -= len(m.FilterID)
		copy(dAtA[i:], m.FilterID)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.FilterID)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SnapTxSum != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.SnapTxSum))
		i--
		dAtA[i] = 0x20
	}
	if m.Epoch != nil {
		{
			size, err := m.Epoch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPeer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Genesis != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.Genesis))
		i--
		dAtA[i] = 0x10
	}
	if m.MsgID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MsgID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerLedgerPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerLedgerPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerLedgerPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extra) > 0 {
		i -= len(m.Extra)
		copy(dAtA[i:], m.Extra)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Extra)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x22
	}
	if m.Last {
		i--
		if m.Last {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.FilterID) > 0 {
		i -= len(m.FilterID)
		copy(dAtA[i:], m.FilterID)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.FilterID)))
		i--
		dAtA[i] = 0x12
	}
	if m.MsgID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MsgID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerLedgerPacketAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerLedgerPacketAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerLedgerPacketAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPeer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Last {
		i--
		if m.Last {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.MsgID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MsgID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerBlocks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerBlocks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerBlocks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extra) > 0 {
		i -= len(m.Extra)
		copy(dAtA[i:], m.Extra)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Extra)))
		i--
		dAtA[i] = 0x32
	}
	if m.StartBlock != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.StartBlock))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Receipts) > 0 {
		for iNdEx := len(m.Receipts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Receipts[iNdEx])
			copy(dAtA[i:], m.Receipts[iNdEx])
			i = encodeVarintPeer(dAtA, i, uint64(len(m.Receipts[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Journal) > 0 {
		for iNdEx := len(m.Journal) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Journal[iNdEx])
			copy(dAtA[i:], m.Journal[iNdEx])
			i = encodeVarintPeer(dAtA, i, uint64(len(m.Journal[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Blocks[iNdEx])
			copy(dAtA[i:], m.Blocks[iNdEx])
			i = encodeVarintPeer(dAtA, i, uint64(len(m.Blocks[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MsgID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MsgID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerBlockAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerBlockAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerBlockAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extra) > 0 {
		i -= len(m.Extra)
		copy(dAtA[i:], m.Extra)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Extra)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPeer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MsgID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MsgID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerHpcBlockAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerHpcBlockAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerHpcBlockAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPeer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MsgID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MsgID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerCheckpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerCheckpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerCheckpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Height != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerQuorumCheckpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerQuorumCheckpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerQuorumCheckpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Checkpoints) > 0 {
		for iNdEx := len(m.Checkpoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Checkpoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPeer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MsgID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MsgID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerQuorumCheckpointAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerQuorumCheckpointAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerQuorumCheckpointAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPeer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Epoch != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if m.MsgID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MsgID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerRollback) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerRollback) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerRollback) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.MsgID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MsgID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerRollbackAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerRollbackAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerRollbackAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPeer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MsgID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MsgID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerAckMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerAckMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerAckMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ok {
		i--
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerDisconnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerDisconnect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerDisconnect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *PeerDisconnectAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerDisconnectAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerDisconnectAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Disconnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Disconnect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Disconnect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DisconnectAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisconnectAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisconnectAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintPeer(dAtA []byte, offset int, v uint64) int {
	offset -= sovPeer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PeerPing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != 0 {
		n += 1 + sovPeer(uint64(m.View))
	}
	if m.MsgID != 0 {
		n += 1 + sovPeer(uint64(m.MsgID))
	}
	return n
}

func (m *PeerPong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != 0 {
		n += 1 + sovPeer(uint64(m.View))
	}
	return n
}

func (m *PeerHandshake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Checkpoint != nil {
		l = m.Checkpoint.Size()
		n += 1 + l + sovPeer(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovPeer(uint64(m.Height))
	}
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	if m.View != 0 {
		n += 1 + sovPeer(uint64(m.View))
	}
	l = len(m.Extra)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	if m.QC != nil {
		l = m.QC.Size()
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *PeerHandshakeResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != 0 {
		n += 1 + sovPeer(uint64(m.View))
	}
	if m.MsgID != 0 {
		n += 1 + sovPeer(uint64(m.MsgID))
	}
	if m.Code != 0 {
		n += 1 + sovPeer(uint64(m.Code))
	}
	l = len(m.Extra)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	if len(m.Checkpoints) > 0 {
		for _, e := range m.Checkpoints {
			l = e.Size()
			n += 1 + l + sovPeer(uint64(l))
		}
	}
	return n
}

func (m *PeerGenesis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgID != 0 {
		n += 1 + sovPeer(uint64(m.MsgID))
	}
	if m.Genesis != 0 {
		n += 1 + sovPeer(uint64(m.Genesis))
	}
	if m.Epoch != nil {
		l = m.Epoch.Size()
		n += 1 + l + sovPeer(uint64(l))
	}
	if m.SnapTxSum != 0 {
		n += 1 + sovPeer(uint64(m.SnapTxSum))
	}
	l = len(m.FilterID)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Block)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Receipt)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	if m.SnapInvalidTxSum != 0 {
		n += 1 + sovPeer(uint64(m.SnapInvalidTxSum))
	}
	return n
}

func (m *PeerLedgerPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgID != 0 {
		n += 1 + sovPeer(uint64(m.MsgID))
	}
	l = len(m.FilterID)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	if m.Last {
		n += 2
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Extra)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *PeerLedgerPacketAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgID != 0 {
		n += 1 + sovPeer(uint64(m.MsgID))
	}
	if m.Last {
		n += 2
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *PeerBlocks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgID != 0 {
		n += 1 + sovPeer(uint64(m.MsgID))
	}
	if len(m.Blocks) > 0 {
		for _, b := range m.Blocks {
			l = len(b)
			n += 1 + l + sovPeer(uint64(l))
		}
	}
	if len(m.Journal) > 0 {
		for _, b := range m.Journal {
			l = len(b)
			n += 1 + l + sovPeer(uint64(l))
		}
	}
	if len(m.Receipts) > 0 {
		for _, b := range m.Receipts {
			l = len(b)
			n += 1 + l + sovPeer(uint64(l))
		}
	}
	if m.StartBlock != 0 {
		n += 1 + sovPeer(uint64(m.StartBlock))
	}
	l = len(m.Extra)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *PeerBlockAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgID != 0 {
		n += 1 + sovPeer(uint64(m.MsgID))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Extra)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *PeerHpcBlockAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgID != 0 {
		n += 1 + sovPeer(uint64(m.MsgID))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *PeerCheckpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovPeer(uint64(m.Height))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *PeerQuorumCheckpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgID != 0 {
		n += 1 + sovPeer(uint64(m.MsgID))
	}
	if len(m.Checkpoints) > 0 {
		for _, e := range m.Checkpoints {
			l = e.Size()
			n += 1 + l + sovPeer(uint64(l))
		}
	}
	return n
}

func (m *PeerQuorumCheckpointAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgID != 0 {
		n += 1 + sovPeer(uint64(m.MsgID))
	}
	if m.Epoch != 0 {
		n += 1 + sovPeer(uint64(m.Epoch))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *PeerRollback) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgID != 0 {
		n += 1 + sovPeer(uint64(m.MsgID))
	}
	if m.Height != 0 {
		n += 1 + sovPeer(uint64(m.Height))
	}
	return n
}

func (m *PeerRollbackAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgID != 0 {
		n += 1 + sovPeer(uint64(m.MsgID))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *PeerAckMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *PeerDisconnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *PeerDisconnectAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Disconnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DisconnectAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovPeer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPeer(x uint64) (n int) {
	return sovPeer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PeerPing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerPing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerPing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerPong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerPong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerPong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerHandshake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerHandshake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerHandshake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Checkpoint == nil {
				m.Checkpoint = &PeerCheckpoint{}
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = append(m.BlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockHash == nil {
				m.BlockHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extra = append(m.Extra[:0], dAtA[iNdEx:postIndex]...)
			if m.Extra == nil {
				m.Extra = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QC == nil {
				m.QC = &QuorumCheckpoint{}
			}
			if err := m.QC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerHandshakeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerHandshakeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerHandshakeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= PeerHandshakeResp_StatsCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extra = append(m.Extra[:0], dAtA[iNdEx:postIndex]...)
			if m.Extra == nil {
				m.Extra = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checkpoints = append(m.Checkpoints, &QuorumCheckpoint{})
			if err := m.Checkpoints[len(m.Checkpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerGenesis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerGenesis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerGenesis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			m.Genesis = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Genesis |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Epoch == nil {
				m.Epoch = &EpochInfo{}
			}
			if err := m.Epoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapTxSum", wireType)
			}
			m.SnapTxSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapTxSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Block = append(m.Block[:0], dAtA[iNdEx:postIndex]...)
			if m.Block == nil {
				m.Block = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = append(m.Journal[:0], dAtA[iNdEx:postIndex]...)
			if m.Journal == nil {
				m.Journal = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receipt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receipt = append(m.Receipt[:0], dAtA[iNdEx:postIndex]...)
			if m.Receipt == nil {
				m.Receipt = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapInvalidTxSum", wireType)
			}
			m.SnapInvalidTxSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapInvalidTxSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerLedgerPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerLedgerPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerLedgerPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Last = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extra = append(m.Extra[:0], dAtA[iNdEx:postIndex]...)
			if m.Extra == nil {
				m.Extra = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerLedgerPacketAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerLedgerPacketAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerLedgerPacketAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Last = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &PeerAckMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerBlocks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerBlocks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerBlocks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, make([]byte, postIndex-iNdEx))
			copy(m.Blocks[len(m.Blocks)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = append(m.Journal, make([]byte, postIndex-iNdEx))
			copy(m.Journal[len(m.Journal)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receipts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receipts = append(m.Receipts, make([]byte, postIndex-iNdEx))
			copy(m.Receipts[len(m.Receipts)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlock", wireType)
			}
			m.StartBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extra = append(m.Extra[:0], dAtA[iNdEx:postIndex]...)
			if m.Extra == nil {
				m.Extra = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerBlockAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerBlockAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerBlockAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &PeerAckMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extra = append(m.Extra[:0], dAtA[iNdEx:postIndex]...)
			if m.Extra == nil {
				m.Extra = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerHpcBlockAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerHpcBlockAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerHpcBlockAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &PeerAckMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerCheckpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerCheckpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerCheckpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerQuorumCheckpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerQuorumCheckpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerQuorumCheckpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checkpoints = append(m.Checkpoints, &QuorumCheckpoint{})
			if err := m.Checkpoints[len(m.Checkpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerQuorumCheckpointAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerQuorumCheckpointAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerQuorumCheckpointAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &PeerAckMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerRollback) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerRollback: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerRollback: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerRollbackAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerRollbackAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerRollbackAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &PeerAckMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerAckMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerAckMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerAckMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerDisconnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerDisconnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerDisconnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerDisconnectAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerDisconnectAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerDisconnectAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Disconnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Disconnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Disconnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisconnectAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisconnectAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisconnectAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPeer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPeer
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPeer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPeer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPeer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPeer
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPeer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPeer   = fmt.Errorf("proto: integer overflow")
)
