// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sync.proto

package protos

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type SyncMsg_Typ int32

const (
	SyncMsg_NegotiateReq      SyncMsg_Typ = 0
	SyncMsg_NegotiateResp     SyncMsg_Typ = 1
	SyncMsg_FetchHPCBlockReq  SyncMsg_Typ = 2
	SyncMsg_FetchHPCBlockResp SyncMsg_Typ = 3
	SyncMsg_FetchHeaderReq    SyncMsg_Typ = 4
	SyncMsg_FetchHeaderResp   SyncMsg_Typ = 5
	SyncMsg_FetchLedgerReq    SyncMsg_Typ = 6
	SyncMsg_FetchLedgerResp   SyncMsg_Typ = 7
	SyncMsg_FetchGenesisReq   SyncMsg_Typ = 8
	SyncMsg_FetchGenesisResp  SyncMsg_Typ = 9
	SyncMsg_FetchBlockReq     SyncMsg_Typ = 10
	SyncMsg_FetchBlockResp    SyncMsg_Typ = 11
)

var SyncMsg_Typ_name = map[int32]string{
	0:  "NegotiateReq",
	1:  "NegotiateResp",
	2:  "FetchHPCBlockReq",
	3:  "FetchHPCBlockResp",
	4:  "FetchHeaderReq",
	5:  "FetchHeaderResp",
	6:  "FetchLedgerReq",
	7:  "FetchLedgerResp",
	8:  "FetchGenesisReq",
	9:  "FetchGenesisResp",
	10: "FetchBlockReq",
	11: "FetchBlockResp",
}

var SyncMsg_Typ_value = map[string]int32{
	"NegotiateReq":      0,
	"NegotiateResp":     1,
	"FetchHPCBlockReq":  2,
	"FetchHPCBlockResp": 3,
	"FetchHeaderReq":    4,
	"FetchHeaderResp":   5,
	"FetchLedgerReq":    6,
	"FetchLedgerResp":   7,
	"FetchGenesisReq":   8,
	"FetchGenesisResp":  9,
	"FetchBlockReq":     10,
	"FetchBlockResp":    11,
}

func (x SyncMsg_Typ) String() string {
	return proto.EnumName(SyncMsg_Typ_name, int32(x))
}

func (SyncMsg_Typ) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{18, 0}
}

type EpochMsg_Typ int32

const (
	EpochMsg_NegotiateReq  EpochMsg_Typ = 0
	EpochMsg_NegotiateResp EpochMsg_Typ = 1
	EpochMsg_FetchReq      EpochMsg_Typ = 2
	EpochMsg_FetchResp     EpochMsg_Typ = 3
)

var EpochMsg_Typ_name = map[int32]string{
	0: "NegotiateReq",
	1: "NegotiateResp",
	2: "FetchReq",
	3: "FetchResp",
}

var EpochMsg_Typ_value = map[string]int32{
	"NegotiateReq":  0,
	"NegotiateResp": 1,
	"FetchReq":      2,
	"FetchResp":     3,
}

func (x EpochMsg_Typ) String() string {
	return proto.EnumName(EpochMsg_Typ_name, int32(x))
}

func (EpochMsg_Typ) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{19, 0}
}

type Error struct {
	Err string `protobuf:"bytes,1,opt,name=Err,proto3" json:"Err,omitempty"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{0}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

type TaskInfo struct {
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Id    uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *TaskInfo) Reset()         { *m = TaskInfo{} }
func (m *TaskInfo) String() string { return proto.CompactTextString(m) }
func (*TaskInfo) ProtoMessage()    {}
func (*TaskInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{1}
}
func (m *TaskInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskInfo.Merge(m, src)
}
func (m *TaskInfo) XXX_Size() int {
	return m.Size()
}
func (m *TaskInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TaskInfo proto.InternalMessageInfo

func (m *TaskInfo) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *TaskInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type FetchBlockHeaderRequest struct {
	Info   *TaskInfo `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	Start  uint64    `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	End    uint64    `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
	Sender string    `protobuf:"bytes,4,opt,name=sender,proto3" json:"sender,omitempty"`
}

func (m *FetchBlockHeaderRequest) Reset()         { *m = FetchBlockHeaderRequest{} }
func (m *FetchBlockHeaderRequest) String() string { return proto.CompactTextString(m) }
func (*FetchBlockHeaderRequest) ProtoMessage()    {}
func (*FetchBlockHeaderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{2}
}
func (m *FetchBlockHeaderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchBlockHeaderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchBlockHeaderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchBlockHeaderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchBlockHeaderRequest.Merge(m, src)
}
func (m *FetchBlockHeaderRequest) XXX_Size() int {
	return m.Size()
}
func (m *FetchBlockHeaderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchBlockHeaderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchBlockHeaderRequest proto.InternalMessageInfo

func (m *FetchBlockHeaderRequest) GetInfo() *TaskInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FetchBlockHeaderRequest) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *FetchBlockHeaderRequest) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *FetchBlockHeaderRequest) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type FetchBlockHeaderResponse struct {
	Info   *TaskInfo `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	Block  []*Block  `protobuf:"bytes,2,rep,name=block,proto3" json:"block,omitempty"`
	Sender string    `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	Err    *Error    `protobuf:"bytes,4,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *FetchBlockHeaderResponse) Reset()         { *m = FetchBlockHeaderResponse{} }
func (m *FetchBlockHeaderResponse) String() string { return proto.CompactTextString(m) }
func (*FetchBlockHeaderResponse) ProtoMessage()    {}
func (*FetchBlockHeaderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{3}
}
func (m *FetchBlockHeaderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchBlockHeaderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchBlockHeaderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchBlockHeaderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchBlockHeaderResponse.Merge(m, src)
}
func (m *FetchBlockHeaderResponse) XXX_Size() int {
	return m.Size()
}
func (m *FetchBlockHeaderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchBlockHeaderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchBlockHeaderResponse proto.InternalMessageInfo

func (m *FetchBlockHeaderResponse) GetInfo() *TaskInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FetchBlockHeaderResponse) GetBlock() []*Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *FetchBlockHeaderResponse) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *FetchBlockHeaderResponse) GetErr() *Error {
	if m != nil {
		return m.Err
	}
	return nil
}

type NegotiateRequest struct {
	Nonce int64  `protobuf:"varint,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	Data  []byte `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *NegotiateRequest) Reset()         { *m = NegotiateRequest{} }
func (m *NegotiateRequest) String() string { return proto.CompactTextString(m) }
func (*NegotiateRequest) ProtoMessage()    {}
func (*NegotiateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{4}
}
func (m *NegotiateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NegotiateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NegotiateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NegotiateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NegotiateRequest.Merge(m, src)
}
func (m *NegotiateRequest) XXX_Size() int {
	return m.Size()
}
func (m *NegotiateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NegotiateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NegotiateRequest proto.InternalMessageInfo

func (m *NegotiateRequest) GetNonce() int64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *NegotiateRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type BlockNegotiateRequest struct {
	ChainHeight  uint64 `protobuf:"varint,1,opt,name=ChainHeight,proto3" json:"ChainHeight,omitempty"`
	TargetHeight uint64 `protobuf:"varint,2,opt,name=TargetHeight,proto3" json:"TargetHeight,omitempty"`
	TargetHash   []byte `protobuf:"bytes,3,opt,name=TargetHash,proto3" json:"TargetHash,omitempty"`
}

func (m *BlockNegotiateRequest) Reset()         { *m = BlockNegotiateRequest{} }
func (m *BlockNegotiateRequest) String() string { return proto.CompactTextString(m) }
func (*BlockNegotiateRequest) ProtoMessage()    {}
func (*BlockNegotiateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{5}
}
func (m *BlockNegotiateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockNegotiateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockNegotiateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockNegotiateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockNegotiateRequest.Merge(m, src)
}
func (m *BlockNegotiateRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlockNegotiateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockNegotiateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlockNegotiateRequest proto.InternalMessageInfo

func (m *BlockNegotiateRequest) GetChainHeight() uint64 {
	if m != nil {
		return m.ChainHeight
	}
	return 0
}

func (m *BlockNegotiateRequest) GetTargetHeight() uint64 {
	if m != nil {
		return m.TargetHeight
	}
	return 0
}

func (m *BlockNegotiateRequest) GetTargetHash() []byte {
	if m != nil {
		return m.TargetHash
	}
	return nil
}

type NegotiateResponse struct {
	Sender string `protobuf:"bytes,1,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Nonce  int64  `protobuf:"varint,2,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	Err    *Error `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
	Data   []byte `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *NegotiateResponse) Reset()         { *m = NegotiateResponse{} }
func (m *NegotiateResponse) String() string { return proto.CompactTextString(m) }
func (*NegotiateResponse) ProtoMessage()    {}
func (*NegotiateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{6}
}
func (m *NegotiateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NegotiateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NegotiateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NegotiateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NegotiateResponse.Merge(m, src)
}
func (m *NegotiateResponse) XXX_Size() int {
	return m.Size()
}
func (m *NegotiateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NegotiateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NegotiateResponse proto.InternalMessageInfo

func (m *NegotiateResponse) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *NegotiateResponse) GetNonce() int64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *NegotiateResponse) GetErr() *Error {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *NegotiateResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type BlockNegotiateResponse struct {
	Genesis            uint64        `protobuf:"varint,1,opt,name=Genesis,proto3" json:"Genesis,omitempty"`
	VersionSplit       uint64        `protobuf:"varint,2,opt,name=VersionSplit,proto3" json:"VersionSplit,omitempty"`
	VersionSplitTxRoot []byte        `protobuf:"bytes,3,opt,name=VersionSplitTxRoot,proto3" json:"VersionSplitTxRoot,omitempty"`
	Sender             string        `protobuf:"bytes,4,opt,name=Sender,proto3" json:"Sender,omitempty"`
	HighestSnapshot    *SnapshotInfo `protobuf:"bytes,5,opt,name=HighestSnapshot,proto3" json:"HighestSnapshot,omitempty"`
	LowestSnapshot     *SnapshotInfo `protobuf:"bytes,6,opt,name=LowestSnapshot,proto3" json:"LowestSnapshot,omitempty"`
	TxVersion          string        `protobuf:"bytes,7,opt,name=TxVersion,proto3" json:"TxVersion,omitempty"`
	Epoch              *EpochInfo    `protobuf:"bytes,8,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *BlockNegotiateResponse) Reset()         { *m = BlockNegotiateResponse{} }
func (m *BlockNegotiateResponse) String() string { return proto.CompactTextString(m) }
func (*BlockNegotiateResponse) ProtoMessage()    {}
func (*BlockNegotiateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{7}
}
func (m *BlockNegotiateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockNegotiateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockNegotiateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockNegotiateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockNegotiateResponse.Merge(m, src)
}
func (m *BlockNegotiateResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlockNegotiateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockNegotiateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlockNegotiateResponse proto.InternalMessageInfo

func (m *BlockNegotiateResponse) GetGenesis() uint64 {
	if m != nil {
		return m.Genesis
	}
	return 0
}

func (m *BlockNegotiateResponse) GetVersionSplit() uint64 {
	if m != nil {
		return m.VersionSplit
	}
	return 0
}

func (m *BlockNegotiateResponse) GetVersionSplitTxRoot() []byte {
	if m != nil {
		return m.VersionSplitTxRoot
	}
	return nil
}

func (m *BlockNegotiateResponse) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *BlockNegotiateResponse) GetHighestSnapshot() *SnapshotInfo {
	if m != nil {
		return m.HighestSnapshot
	}
	return nil
}

func (m *BlockNegotiateResponse) GetLowestSnapshot() *SnapshotInfo {
	if m != nil {
		return m.LowestSnapshot
	}
	return nil
}

func (m *BlockNegotiateResponse) GetTxVersion() string {
	if m != nil {
		return m.TxVersion
	}
	return ""
}

func (m *BlockNegotiateResponse) GetEpoch() *EpochInfo {
	if m != nil {
		return m.Epoch
	}
	return nil
}

type SnapshotInfo struct {
	Height       uint64 `protobuf:"varint,1,opt,name=Height,proto3" json:"Height,omitempty"`
	TxNum        uint64 `protobuf:"varint,2,opt,name=TxNum,proto3" json:"TxNum,omitempty"`
	InvalidTxNum uint64 `protobuf:"varint,3,opt,name=InvalidTxNum,proto3" json:"InvalidTxNum,omitempty"`
	Size_        uint64 `protobuf:"varint,4,opt,name=Size,proto3" json:"Size,omitempty"`
	FilterID     string `protobuf:"bytes,5,opt,name=FilterID,proto3" json:"FilterID,omitempty"`
}

func (m *SnapshotInfo) Reset()         { *m = SnapshotInfo{} }
func (m *SnapshotInfo) String() string { return proto.CompactTextString(m) }
func (*SnapshotInfo) ProtoMessage()    {}
func (*SnapshotInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{8}
}
func (m *SnapshotInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotInfo.Merge(m, src)
}
func (m *SnapshotInfo) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotInfo proto.InternalMessageInfo

func (m *SnapshotInfo) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *SnapshotInfo) GetTxNum() uint64 {
	if m != nil {
		return m.TxNum
	}
	return 0
}

func (m *SnapshotInfo) GetInvalidTxNum() uint64 {
	if m != nil {
		return m.InvalidTxNum
	}
	return 0
}

func (m *SnapshotInfo) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SnapshotInfo) GetFilterID() string {
	if m != nil {
		return m.FilterID
	}
	return ""
}

type FetchGenesisRequest struct {
	Info   *TaskInfo `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
	Height uint64    `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
}

func (m *FetchGenesisRequest) Reset()         { *m = FetchGenesisRequest{} }
func (m *FetchGenesisRequest) String() string { return proto.CompactTextString(m) }
func (*FetchGenesisRequest) ProtoMessage()    {}
func (*FetchGenesisRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{9}
}
func (m *FetchGenesisRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchGenesisRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchGenesisRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchGenesisRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchGenesisRequest.Merge(m, src)
}
func (m *FetchGenesisRequest) XXX_Size() int {
	return m.Size()
}
func (m *FetchGenesisRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchGenesisRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchGenesisRequest proto.InternalMessageInfo

func (m *FetchGenesisRequest) GetInfo() *TaskInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FetchGenesisRequest) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type FetchGenesisResponse struct {
	Info    *TaskInfo  `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
	Height  uint64     `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
	Payload *BJRPacket `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	Err     *Error     `protobuf:"bytes,4,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *FetchGenesisResponse) Reset()         { *m = FetchGenesisResponse{} }
func (m *FetchGenesisResponse) String() string { return proto.CompactTextString(m) }
func (*FetchGenesisResponse) ProtoMessage()    {}
func (*FetchGenesisResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{10}
}
func (m *FetchGenesisResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchGenesisResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchGenesisResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchGenesisResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchGenesisResponse.Merge(m, src)
}
func (m *FetchGenesisResponse) XXX_Size() int {
	return m.Size()
}
func (m *FetchGenesisResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchGenesisResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchGenesisResponse proto.InternalMessageInfo

func (m *FetchGenesisResponse) GetInfo() *TaskInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FetchGenesisResponse) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *FetchGenesisResponse) GetPayload() *BJRPacket {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *FetchGenesisResponse) GetErr() *Error {
	if m != nil {
		return m.Err
	}
	return nil
}

type BJRPacket struct {
	BlockWrapper   []byte `protobuf:"bytes,1,opt,name=blockWrapper,proto3" json:"blockWrapper,omitempty"`
	Journal        []byte `protobuf:"bytes,2,opt,name=journal,proto3" json:"journal,omitempty"`
	ReceiptWrapper []byte `protobuf:"bytes,3,opt,name=receiptWrapper,proto3" json:"receiptWrapper,omitempty"`
	Number         uint64 `protobuf:"varint,4,opt,name=Number,proto3" json:"Number,omitempty"`
}

func (m *BJRPacket) Reset()         { *m = BJRPacket{} }
func (m *BJRPacket) String() string { return proto.CompactTextString(m) }
func (*BJRPacket) ProtoMessage()    {}
func (*BJRPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{11}
}
func (m *BJRPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BJRPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BJRPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BJRPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BJRPacket.Merge(m, src)
}
func (m *BJRPacket) XXX_Size() int {
	return m.Size()
}
func (m *BJRPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_BJRPacket.DiscardUnknown(m)
}

var xxx_messageInfo_BJRPacket proto.InternalMessageInfo

func (m *BJRPacket) GetBlockWrapper() []byte {
	if m != nil {
		return m.BlockWrapper
	}
	return nil
}

func (m *BJRPacket) GetJournal() []byte {
	if m != nil {
		return m.Journal
	}
	return nil
}

func (m *BJRPacket) GetReceiptWrapper() []byte {
	if m != nil {
		return m.ReceiptWrapper
	}
	return nil
}

func (m *BJRPacket) GetNumber() uint64 {
	if m != nil {
		return m.Number
	}
	return 0
}

type FetchHPCBlocksRequest struct {
	Info  *TaskInfo `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
	Start uint64    `protobuf:"varint,2,opt,name=Start,proto3" json:"Start,omitempty"`
	End   uint64    `protobuf:"varint,3,opt,name=End,proto3" json:"End,omitempty"`
}

func (m *FetchHPCBlocksRequest) Reset()         { *m = FetchHPCBlocksRequest{} }
func (m *FetchHPCBlocksRequest) String() string { return proto.CompactTextString(m) }
func (*FetchHPCBlocksRequest) ProtoMessage()    {}
func (*FetchHPCBlocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{12}
}
func (m *FetchHPCBlocksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchHPCBlocksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchHPCBlocksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchHPCBlocksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchHPCBlocksRequest.Merge(m, src)
}
func (m *FetchHPCBlocksRequest) XXX_Size() int {
	return m.Size()
}
func (m *FetchHPCBlocksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchHPCBlocksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchHPCBlocksRequest proto.InternalMessageInfo

func (m *FetchHPCBlocksRequest) GetInfo() *TaskInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FetchHPCBlocksRequest) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *FetchHPCBlocksRequest) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

type FetchHPCBlocksResponse struct {
	Info *TaskInfo  `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
	BJR  *BJRPacket `protobuf:"bytes,2,opt,name=BJR,proto3" json:"BJR,omitempty"`
	Err  *Error     `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *FetchHPCBlocksResponse) Reset()         { *m = FetchHPCBlocksResponse{} }
func (m *FetchHPCBlocksResponse) String() string { return proto.CompactTextString(m) }
func (*FetchHPCBlocksResponse) ProtoMessage()    {}
func (*FetchHPCBlocksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{13}
}
func (m *FetchHPCBlocksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchHPCBlocksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchHPCBlocksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchHPCBlocksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchHPCBlocksResponse.Merge(m, src)
}
func (m *FetchHPCBlocksResponse) XXX_Size() int {
	return m.Size()
}
func (m *FetchHPCBlocksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchHPCBlocksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchHPCBlocksResponse proto.InternalMessageInfo

func (m *FetchHPCBlocksResponse) GetInfo() *TaskInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FetchHPCBlocksResponse) GetBJR() *BJRPacket {
	if m != nil {
		return m.BJR
	}
	return nil
}

func (m *FetchHPCBlocksResponse) GetErr() *Error {
	if m != nil {
		return m.Err
	}
	return nil
}

type FetchLedgerRequest struct {
	Info     *TaskInfo `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
	Position uint64    `protobuf:"varint,2,opt,name=Position,proto3" json:"Position,omitempty"`
	PartSize uint64    `protobuf:"varint,3,opt,name=PartSize,proto3" json:"PartSize,omitempty"`
	FilterID string    `protobuf:"bytes,4,opt,name=FilterID,proto3" json:"FilterID,omitempty"`
}

func (m *FetchLedgerRequest) Reset()         { *m = FetchLedgerRequest{} }
func (m *FetchLedgerRequest) String() string { return proto.CompactTextString(m) }
func (*FetchLedgerRequest) ProtoMessage()    {}
func (*FetchLedgerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{14}
}
func (m *FetchLedgerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchLedgerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchLedgerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchLedgerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchLedgerRequest.Merge(m, src)
}
func (m *FetchLedgerRequest) XXX_Size() int {
	return m.Size()
}
func (m *FetchLedgerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchLedgerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchLedgerRequest proto.InternalMessageInfo

func (m *FetchLedgerRequest) GetInfo() *TaskInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FetchLedgerRequest) GetPosition() uint64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *FetchLedgerRequest) GetPartSize() uint64 {
	if m != nil {
		return m.PartSize
	}
	return 0
}

func (m *FetchLedgerRequest) GetFilterID() string {
	if m != nil {
		return m.FilterID
	}
	return ""
}

type FetchLedgerResponse struct {
	Info     *TaskInfo `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
	Ledger   []byte    `protobuf:"bytes,2,opt,name=Ledger,proto3" json:"Ledger,omitempty"`
	Checksum []byte    `protobuf:"bytes,3,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	Position uint64    `protobuf:"varint,4,opt,name=Position,proto3" json:"Position,omitempty"`
	Err      *Error    `protobuf:"bytes,5,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *FetchLedgerResponse) Reset()         { *m = FetchLedgerResponse{} }
func (m *FetchLedgerResponse) String() string { return proto.CompactTextString(m) }
func (*FetchLedgerResponse) ProtoMessage()    {}
func (*FetchLedgerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{15}
}
func (m *FetchLedgerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchLedgerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchLedgerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchLedgerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchLedgerResponse.Merge(m, src)
}
func (m *FetchLedgerResponse) XXX_Size() int {
	return m.Size()
}
func (m *FetchLedgerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchLedgerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchLedgerResponse proto.InternalMessageInfo

func (m *FetchLedgerResponse) GetInfo() *TaskInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FetchLedgerResponse) GetLedger() []byte {
	if m != nil {
		return m.Ledger
	}
	return nil
}

func (m *FetchLedgerResponse) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *FetchLedgerResponse) GetPosition() uint64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *FetchLedgerResponse) GetErr() *Error {
	if m != nil {
		return m.Err
	}
	return nil
}

type FetchBlockRequest struct {
	Info        *TaskInfo `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
	Start       uint64    `protobuf:"varint,2,opt,name=Start,proto3" json:"Start,omitempty"`
	End         uint64    `protobuf:"varint,3,opt,name=End,proto3" json:"End,omitempty"`
	NeedJournal bool      `protobuf:"varint,4,opt,name=NeedJournal,proto3" json:"NeedJournal,omitempty"`
	NeedReceipt bool      `protobuf:"varint,5,opt,name=NeedReceipt,proto3" json:"NeedReceipt,omitempty"`
}

func (m *FetchBlockRequest) Reset()         { *m = FetchBlockRequest{} }
func (m *FetchBlockRequest) String() string { return proto.CompactTextString(m) }
func (*FetchBlockRequest) ProtoMessage()    {}
func (*FetchBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{16}
}
func (m *FetchBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchBlockRequest.Merge(m, src)
}
func (m *FetchBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *FetchBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchBlockRequest proto.InternalMessageInfo

func (m *FetchBlockRequest) GetInfo() *TaskInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FetchBlockRequest) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *FetchBlockRequest) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *FetchBlockRequest) GetNeedJournal() bool {
	if m != nil {
		return m.NeedJournal
	}
	return false
}

func (m *FetchBlockRequest) GetNeedReceipt() bool {
	if m != nil {
		return m.NeedReceipt
	}
	return false
}

type FetchBlockResponse struct {
	Info    *TaskInfo    `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
	Payload []*BJRPacket `protobuf:"bytes,2,rep,name=payload,proto3" json:"payload,omitempty"`
	Err     *Error       `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *FetchBlockResponse) Reset()         { *m = FetchBlockResponse{} }
func (m *FetchBlockResponse) String() string { return proto.CompactTextString(m) }
func (*FetchBlockResponse) ProtoMessage()    {}
func (*FetchBlockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{17}
}
func (m *FetchBlockResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchBlockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchBlockResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchBlockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchBlockResponse.Merge(m, src)
}
func (m *FetchBlockResponse) XXX_Size() int {
	return m.Size()
}
func (m *FetchBlockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchBlockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchBlockResponse proto.InternalMessageInfo

func (m *FetchBlockResponse) GetInfo() *TaskInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FetchBlockResponse) GetPayload() []*BJRPacket {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *FetchBlockResponse) GetErr() *Error {
	if m != nil {
		return m.Err
	}
	return nil
}

type SyncMsg struct {
	Typ     SyncMsg_Typ `protobuf:"varint,1,opt,name=typ,proto3,enum=protos.SyncMsg_Typ" json:"typ,omitempty"`
	Payload []byte      `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SyncMsg) Reset()         { *m = SyncMsg{} }
func (m *SyncMsg) String() string { return proto.CompactTextString(m) }
func (*SyncMsg) ProtoMessage()    {}
func (*SyncMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{18}
}
func (m *SyncMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncMsg.Merge(m, src)
}
func (m *SyncMsg) XXX_Size() int {
	return m.Size()
}
func (m *SyncMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncMsg.DiscardUnknown(m)
}

var xxx_messageInfo_SyncMsg proto.InternalMessageInfo

func (m *SyncMsg) GetTyp() SyncMsg_Typ {
	if m != nil {
		return m.Typ
	}
	return SyncMsg_NegotiateReq
}

func (m *SyncMsg) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type EpochMsg struct {
	Typ     EpochMsg_Typ `protobuf:"varint,1,opt,name=typ,proto3,enum=protos.EpochMsg_Typ" json:"typ,omitempty"`
	Payload []byte       `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *EpochMsg) Reset()         { *m = EpochMsg{} }
func (m *EpochMsg) String() string { return proto.CompactTextString(m) }
func (*EpochMsg) ProtoMessage()    {}
func (*EpochMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{19}
}
func (m *EpochMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochMsg.Merge(m, src)
}
func (m *EpochMsg) XXX_Size() int {
	return m.Size()
}
func (m *EpochMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochMsg.DiscardUnknown(m)
}

var xxx_messageInfo_EpochMsg proto.InternalMessageInfo

func (m *EpochMsg) GetTyp() EpochMsg_Typ {
	if m != nil {
		return m.Typ
	}
	return EpochMsg_NegotiateReq
}

func (m *EpochMsg) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type EpochNegotiateRequest struct {
	TargetEpoch uint64 `protobuf:"varint,1,opt,name=TargetEpoch,proto3" json:"TargetEpoch,omitempty"`
	InitEpoch   uint64 `protobuf:"varint,2,opt,name=InitEpoch,proto3" json:"InitEpoch,omitempty"`
}

func (m *EpochNegotiateRequest) Reset()         { *m = EpochNegotiateRequest{} }
func (m *EpochNegotiateRequest) String() string { return proto.CompactTextString(m) }
func (*EpochNegotiateRequest) ProtoMessage()    {}
func (*EpochNegotiateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{20}
}
func (m *EpochNegotiateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochNegotiateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochNegotiateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochNegotiateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochNegotiateRequest.Merge(m, src)
}
func (m *EpochNegotiateRequest) XXX_Size() int {
	return m.Size()
}
func (m *EpochNegotiateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochNegotiateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EpochNegotiateRequest proto.InternalMessageInfo

func (m *EpochNegotiateRequest) GetTargetEpoch() uint64 {
	if m != nil {
		return m.TargetEpoch
	}
	return 0
}

func (m *EpochNegotiateRequest) GetInitEpoch() uint64 {
	if m != nil {
		return m.InitEpoch
	}
	return 0
}

type EpochNegotiateResponse struct {
}

func (m *EpochNegotiateResponse) Reset()         { *m = EpochNegotiateResponse{} }
func (m *EpochNegotiateResponse) String() string { return proto.CompactTextString(m) }
func (*EpochNegotiateResponse) ProtoMessage()    {}
func (*EpochNegotiateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{21}
}
func (m *EpochNegotiateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochNegotiateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochNegotiateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochNegotiateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochNegotiateResponse.Merge(m, src)
}
func (m *EpochNegotiateResponse) XXX_Size() int {
	return m.Size()
}
func (m *EpochNegotiateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochNegotiateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EpochNegotiateResponse proto.InternalMessageInfo

type FetchEpochRequest struct {
	Info  *TaskInfo `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
	Start uint64    `protobuf:"varint,2,opt,name=Start,proto3" json:"Start,omitempty"`
	End   uint64    `protobuf:"varint,3,opt,name=End,proto3" json:"End,omitempty"`
}

func (m *FetchEpochRequest) Reset()         { *m = FetchEpochRequest{} }
func (m *FetchEpochRequest) String() string { return proto.CompactTextString(m) }
func (*FetchEpochRequest) ProtoMessage()    {}
func (*FetchEpochRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{22}
}
func (m *FetchEpochRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchEpochRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchEpochRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchEpochRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchEpochRequest.Merge(m, src)
}
func (m *FetchEpochRequest) XXX_Size() int {
	return m.Size()
}
func (m *FetchEpochRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchEpochRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchEpochRequest proto.InternalMessageInfo

func (m *FetchEpochRequest) GetInfo() *TaskInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FetchEpochRequest) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *FetchEpochRequest) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

type FetchEpochResponse struct {
	Info        *TaskInfo           `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
	Checkpoints []*QuorumCheckpoint `protobuf:"bytes,2,rep,name=checkpoints,proto3" json:"checkpoints,omitempty"`
	Err         *Error              `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *FetchEpochResponse) Reset()         { *m = FetchEpochResponse{} }
func (m *FetchEpochResponse) String() string { return proto.CompactTextString(m) }
func (*FetchEpochResponse) ProtoMessage()    {}
func (*FetchEpochResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5273b98214de8075, []int{23}
}
func (m *FetchEpochResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchEpochResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchEpochResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchEpochResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchEpochResponse.Merge(m, src)
}
func (m *FetchEpochResponse) XXX_Size() int {
	return m.Size()
}
func (m *FetchEpochResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchEpochResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchEpochResponse proto.InternalMessageInfo

func (m *FetchEpochResponse) GetInfo() *TaskInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FetchEpochResponse) GetCheckpoints() []*QuorumCheckpoint {
	if m != nil {
		return m.Checkpoints
	}
	return nil
}

func (m *FetchEpochResponse) GetErr() *Error {
	if m != nil {
		return m.Err
	}
	return nil
}

func init() {
	proto.RegisterEnum("protos.SyncMsg_Typ", SyncMsg_Typ_name, SyncMsg_Typ_value)
	proto.RegisterEnum("protos.EpochMsg_Typ", EpochMsg_Typ_name, EpochMsg_Typ_value)
	proto.RegisterType((*Error)(nil), "protos.Error")
	proto.RegisterType((*TaskInfo)(nil), "protos.TaskInfo")
	proto.RegisterType((*FetchBlockHeaderRequest)(nil), "protos.FetchBlockHeaderRequest")
	proto.RegisterType((*FetchBlockHeaderResponse)(nil), "protos.FetchBlockHeaderResponse")
	proto.RegisterType((*NegotiateRequest)(nil), "protos.NegotiateRequest")
	proto.RegisterType((*BlockNegotiateRequest)(nil), "protos.BlockNegotiateRequest")
	proto.RegisterType((*NegotiateResponse)(nil), "protos.NegotiateResponse")
	proto.RegisterType((*BlockNegotiateResponse)(nil), "protos.BlockNegotiateResponse")
	proto.RegisterType((*SnapshotInfo)(nil), "protos.SnapshotInfo")
	proto.RegisterType((*FetchGenesisRequest)(nil), "protos.FetchGenesisRequest")
	proto.RegisterType((*FetchGenesisResponse)(nil), "protos.FetchGenesisResponse")
	proto.RegisterType((*BJRPacket)(nil), "protos.BJRPacket")
	proto.RegisterType((*FetchHPCBlocksRequest)(nil), "protos.FetchHPCBlocksRequest")
	proto.RegisterType((*FetchHPCBlocksResponse)(nil), "protos.FetchHPCBlocksResponse")
	proto.RegisterType((*FetchLedgerRequest)(nil), "protos.FetchLedgerRequest")
	proto.RegisterType((*FetchLedgerResponse)(nil), "protos.FetchLedgerResponse")
	proto.RegisterType((*FetchBlockRequest)(nil), "protos.FetchBlockRequest")
	proto.RegisterType((*FetchBlockResponse)(nil), "protos.FetchBlockResponse")
	proto.RegisterType((*SyncMsg)(nil), "protos.SyncMsg")
	proto.RegisterType((*EpochMsg)(nil), "protos.EpochMsg")
	proto.RegisterType((*EpochNegotiateRequest)(nil), "protos.EpochNegotiateRequest")
	proto.RegisterType((*EpochNegotiateResponse)(nil), "protos.EpochNegotiateResponse")
	proto.RegisterType((*FetchEpochRequest)(nil), "protos.FetchEpochRequest")
	proto.RegisterType((*FetchEpochResponse)(nil), "protos.FetchEpochResponse")
}

func init() { proto.RegisterFile("sync.proto", fileDescriptor_5273b98214de8075) }

var fileDescriptor_5273b98214de8075 = []byte{
	// 1194 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0x7a, 0xed, 0xc4, 0x7e, 0x71, 0xd2, 0xcd, 0xc4, 0x09, 0x4b, 0x84, 0x4c, 0xb4, 0x85,
	0x52, 0x09, 0x35, 0xa9, 0xc2, 0x0d, 0x45, 0x48, 0x24, 0x4d, 0x9b, 0x44, 0x25, 0x0a, 0x63, 0x8b,
	0x4a, 0xdc, 0x36, 0xeb, 0xa9, 0x77, 0x89, 0xbd, 0xb3, 0xec, 0x8c, 0x4b, 0x8c, 0x84, 0xb8, 0x70,
	0x80, 0x0b, 0xea, 0x05, 0x71, 0xe3, 0x80, 0xc4, 0x8d, 0x0f, 0xd2, 0x63, 0x8f, 0x1c, 0x51, 0xf2,
	0x31, 0xb8, 0xa0, 0xf9, 0xb3, 0xbb, 0xb3, 0x6e, 0xd2, 0xc4, 0x95, 0x7a, 0xf2, 0xbe, 0x3f, 0x33,
	0xef, 0xbd, 0xdf, 0xbc, 0xdf, 0x9b, 0x31, 0x00, 0x1b, 0xc7, 0xc1, 0x46, 0x92, 0x52, 0x4e, 0xd1,
	0xac, 0xfc, 0x61, 0x6b, 0xdb, 0xfd, 0x88, 0x87, 0xa3, 0x93, 0x8d, 0x80, 0x0e, 0x37, 0xc3, 0x71,
	0x42, 0xd2, 0x20, 0xf4, 0xa3, 0x78, 0xb3, 0x4f, 0xef, 0x85, 0x49, 0x70, 0x2f, 0xa0, 0xc3, 0x21,
	0x8d, 0x37, 0xf9, 0x38, 0x21, 0x6c, 0x53, 0xad, 0xd8, 0x3c, 0x19, 0xd0, 0xe0, 0x54, 0xed, 0xb2,
	0xf6, 0xf9, 0xd4, 0xab, 0x83, 0x90, 0x04, 0xa7, 0x09, 0x8d, 0x62, 0xae, 0xb6, 0xf0, 0xde, 0x85,
	0xda, 0x5e, 0x9a, 0xd2, 0x14, 0x39, 0x60, 0xef, 0xa5, 0xa9, 0x6b, 0xad, 0x5b, 0x77, 0x1b, 0x58,
	0x7c, 0x7a, 0xf7, 0xa1, 0xde, 0xf5, 0xd9, 0xe9, 0x41, 0xfc, 0x94, 0xa2, 0x16, 0xd4, 0x62, 0x1a,
	0x07, 0x44, 0xda, 0xab, 0x58, 0x09, 0x68, 0x11, 0x2a, 0x51, 0xcf, 0xad, 0x48, 0x55, 0x25, 0xea,
	0x79, 0x3f, 0xc2, 0x3b, 0x0f, 0x09, 0x0f, 0xc2, 0x1d, 0x91, 0xe3, 0x3e, 0xf1, 0x7b, 0x24, 0xc5,
	0xe4, 0xdb, 0x11, 0x61, 0x1c, 0x7d, 0x00, 0xd5, 0x28, 0x7e, 0x4a, 0xe5, 0xfa, 0xf9, 0x2d, 0x47,
	0x45, 0x67, 0x1b, 0x59, 0x00, 0x2c, 0xad, 0x22, 0x0c, 0xe3, 0x7e, 0xca, 0xf5, 0x9e, 0x4a, 0x10,
	0xa9, 0x91, 0xb8, 0xe7, 0xda, 0x52, 0x27, 0x3e, 0xd1, 0x2a, 0xcc, 0x32, 0x12, 0xf7, 0x48, 0xea,
	0x56, 0x65, 0xbe, 0x5a, 0xf2, 0xfe, 0xb0, 0xc0, 0x7d, 0x35, 0x03, 0x96, 0xd0, 0x98, 0x91, 0x1b,
	0xa6, 0x70, 0x1b, 0x6a, 0x12, 0x62, 0xb7, 0xb2, 0x6e, 0xdf, 0x9d, 0xdf, 0x5a, 0xc8, 0xdc, 0xe4,
	0x8e, 0x58, 0xd9, 0x8c, 0xf8, 0xb6, 0x19, 0x1f, 0xbd, 0x0f, 0x36, 0x49, 0x55, 0x52, 0xc6, 0x52,
	0x09, 0x30, 0x16, 0x16, 0x6f, 0x1b, 0x9c, 0x23, 0xd2, 0xa7, 0x3c, 0xf2, 0x39, 0xc9, 0xa0, 0x69,
	0x41, 0xed, 0x28, 0xc7, 0xd6, 0xc6, 0x4a, 0x40, 0x08, 0xaa, 0x0f, 0x7c, 0xee, 0x4b, 0x24, 0x9a,
	0x58, 0x7e, 0x7b, 0x3f, 0xc0, 0x8a, 0x4c, 0xe3, 0x95, 0x2d, 0xd6, 0x61, 0x7e, 0x57, 0x1c, 0xfd,
	0x3e, 0x89, 0xfa, 0x21, 0xd7, 0x87, 0x64, 0xaa, 0x90, 0x07, 0xcd, 0xae, 0x9f, 0xf6, 0x09, 0xd7,
	0x2e, 0x0a, 0xe0, 0x92, 0x0e, 0xb5, 0x01, 0xb4, 0xec, 0xb3, 0x50, 0x56, 0xd6, 0xc4, 0x86, 0xc6,
	0x7b, 0x06, 0x4b, 0x46, 0x64, 0x8d, 0xea, 0x2a, 0xcc, 0x76, 0x14, 0x14, 0xaa, 0x75, 0xb4, 0x54,
	0x54, 0x55, 0x31, 0xab, 0xd2, 0x00, 0xd9, 0x57, 0x01, 0x94, 0x97, 0x5d, 0x35, 0xca, 0xbe, 0xa8,
	0xc0, 0xea, 0x64, 0xdd, 0x3a, 0xba, 0x0b, 0x73, 0x8f, 0x48, 0x4c, 0x58, 0xc4, 0x74, 0xd1, 0x99,
	0x28, 0x0a, 0xfe, 0x8a, 0xa4, 0x2c, 0xa2, 0x71, 0x27, 0x19, 0x44, 0x79, 0xc1, 0xa6, 0x0e, 0x6d,
	0x00, 0x32, 0xe5, 0xee, 0x19, 0xa6, 0x94, 0xeb, 0xc2, 0x2f, 0xb1, 0x18, 0xb5, 0x56, 0x4b, 0xb5,
	0x7e, 0x06, 0xb7, 0xf6, 0xa3, 0x7e, 0x48, 0x18, 0xef, 0xc4, 0x7e, 0xc2, 0x42, 0xca, 0xdd, 0x9a,
	0xac, 0xb0, 0x95, 0x55, 0x98, 0xe9, 0x65, 0xa3, 0x4d, 0x3a, 0xa3, 0x6d, 0x58, 0x7c, 0x4c, 0xbf,
	0x33, 0x97, 0xcf, 0xbe, 0x66, 0xf9, 0x84, 0x2f, 0x7a, 0x0f, 0x1a, 0xdd, 0x33, 0x9d, 0xad, 0x3b,
	0x27, 0x13, 0x2b, 0x14, 0xe8, 0x23, 0xa8, 0x91, 0x84, 0x06, 0xa1, 0x5b, 0x97, 0x5b, 0x2e, 0xe5,
	0x98, 0x0b, 0xa5, 0xdc, 0x4f, 0xd9, 0xbd, 0xe7, 0x16, 0x34, 0xcd, 0x38, 0xa2, 0xda, 0x52, 0x3f,
	0x69, 0x49, 0x9c, 0x6c, 0xf7, 0xec, 0x68, 0x34, 0xcc, 0x48, 0x2a, 0x05, 0x81, 0xf7, 0x41, 0xfc,
	0xcc, 0x1f, 0x44, 0x3d, 0x65, 0x54, 0x6c, 0x2d, 0xe9, 0xc4, 0xe1, 0x76, 0xa2, 0xef, 0x89, 0x44,
	0xaf, 0x8a, 0xe5, 0x37, 0x5a, 0x83, 0xfa, 0xc3, 0x68, 0xc0, 0x49, 0x7a, 0xf0, 0x40, 0x82, 0xd6,
	0xc0, 0xb9, 0xec, 0x75, 0x60, 0x59, 0xb2, 0x59, 0x9f, 0xa9, 0x31, 0x4b, 0x0e, 0x5e, 0x4b, 0xe4,
	0x89, 0xf4, 0x2b, 0x66, 0xfa, 0xde, 0x9f, 0x16, 0xb4, 0xca, 0xbb, 0x16, 0xf3, 0xe1, 0xcd, 0xb7,
	0x45, 0x1f, 0xc3, 0x5c, 0xe2, 0x8f, 0x07, 0xd4, 0xef, 0xe9, 0xee, 0xce, 0x91, 0xde, 0x39, 0xc4,
	0xc7, 0x7e, 0x70, 0x4a, 0x38, 0xce, 0x3c, 0xae, 0x9f, 0x13, 0xbf, 0x58, 0xd0, 0xc8, 0xd7, 0x09,
	0x6c, 0xe5, 0xdc, 0x79, 0x92, 0xfa, 0x49, 0xa2, 0x99, 0xd6, 0xc4, 0x25, 0x9d, 0x60, 0xc2, 0x37,
	0x74, 0x94, 0xc6, 0xfe, 0x40, 0x8f, 0x8c, 0x4c, 0x44, 0x77, 0x60, 0x31, 0x25, 0x01, 0x89, 0x12,
	0x9e, 0xad, 0x57, 0x1d, 0x3e, 0xa1, 0x15, 0x95, 0x1d, 0x8d, 0x86, 0x27, 0xba, 0xbb, 0xab, 0x58,
	0x4b, 0x1e, 0x81, 0x15, 0x89, 0xd7, 0xfe, 0xf1, 0xae, 0x64, 0xe1, 0x94, 0xe7, 0xd0, 0x82, 0x5a,
	0xc7, 0x9c, 0xe9, 0x9d, 0x6c, 0xa6, 0xef, 0x15, 0x33, 0x7d, 0x2f, 0xee, 0x79, 0x3f, 0x59, 0xb0,
	0x3a, 0x19, 0x67, 0xaa, 0x93, 0xb9, 0x0d, 0xf6, 0xce, 0x21, 0x96, 0x61, 0x2e, 0x45, 0x5f, 0x58,
	0xaf, 0x1d, 0x40, 0xde, 0xaf, 0x16, 0x20, 0x99, 0xc6, 0x63, 0xd2, 0xeb, 0x97, 0xee, 0xaf, 0x1b,
	0xa4, 0xb0, 0x06, 0xf5, 0x63, 0xca, 0x22, 0x2e, 0x98, 0xa8, 0xca, 0xcd, 0x65, 0x69, 0xf3, 0x53,
	0x2e, 0x09, 0x60, 0x6b, 0x9b, 0x96, 0x4b, 0x24, 0xa8, 0x4e, 0x90, 0xe0, 0x6f, 0x4b, 0xb3, 0x20,
	0x4b, 0x68, 0xda, 0x76, 0x55, 0xeb, 0x74, 0x57, 0x68, 0x49, 0x44, 0xdc, 0x15, 0x6f, 0x01, 0xa6,
	0xa9, 0xda, 0xc4, 0xb9, 0x5c, 0xaa, 0xa2, 0x3a, 0x51, 0x85, 0xc6, 0xaf, 0x76, 0x25, 0x7e, 0x7f,
	0x59, 0xb0, 0x54, 0x5c, 0xc1, 0x6f, 0xa5, 0x55, 0xc4, 0x75, 0x77, 0x44, 0x48, 0xef, 0x50, 0xf7,
	0xbb, 0xc8, 0xb1, 0x8e, 0x4d, 0x55, 0xe6, 0x81, 0x55, 0x87, 0xcb, 0x74, 0xb5, 0x87, 0x56, 0x79,
	0x3f, 0x67, 0xe7, 0xac, 0xf3, 0x9c, 0x0a, 0x55, 0x83, 0xec, 0xea, 0x99, 0x70, 0x03, 0xb2, 0x5f,
	0xdd, 0x72, 0x2f, 0x2a, 0x30, 0xd7, 0x19, 0xc7, 0xc1, 0x17, 0xac, 0x8f, 0x3e, 0x04, 0x9b, 0x8f,
	0x13, 0x19, 0x7e, 0x71, 0x6b, 0x39, 0x9f, 0xff, 0xca, 0xba, 0xd1, 0x1d, 0x27, 0x58, 0xd8, 0x05,
	0xdb, 0x8b, 0x04, 0x24, 0xdb, 0xb5, 0xe8, 0xfd, 0x67, 0x81, 0xdd, 0x1d, 0x27, 0xc8, 0x81, 0xa6,
	0xf9, 0x4c, 0x70, 0x66, 0xd0, 0x12, 0x2c, 0x94, 0x2e, 0x50, 0xc7, 0x42, 0x2d, 0x70, 0x4a, 0x94,
	0x13, 0x8e, 0x15, 0xb4, 0xa2, 0x4f, 0xb0, 0xd0, 0xb2, 0xc4, 0xb1, 0x11, 0x82, 0x45, 0xa5, 0xce,
	0x1e, 0x76, 0x4e, 0x15, 0x2d, 0xc3, 0xad, 0x92, 0x8e, 0x25, 0x4e, 0x2d, 0x77, 0xcc, 0x19, 0xe4,
	0xcc, 0xe6, 0x8e, 0x45, 0x13, 0x3b, 0x73, 0xb9, 0xb2, 0x98, 0xef, 0x4e, 0x3d, 0xcf, 0xc9, 0x18,
	0xcf, 0x4e, 0x43, 0x24, 0x5f, 0xea, 0x2a, 0x07, 0xf2, 0x30, 0x45, 0x8e, 0xf3, 0xde, 0x6f, 0x16,
	0xd4, 0xe5, 0xcd, 0x26, 0xb0, 0xbc, 0x63, 0x62, 0xd9, 0x2a, 0x5d, 0x7c, 0x37, 0x04, 0xf3, 0xd1,
	0x14, 0x58, 0x36, 0xa1, 0x2e, 0xd3, 0x51, 0x18, 0x2e, 0x40, 0x43, 0x4b, 0x02, 0x3b, 0xef, 0x09,
	0xac, 0xc8, 0xb8, 0x97, 0xbd, 0xdc, 0xd4, 0x0b, 0x4b, 0x9a, 0xb3, 0x97, 0x9b, 0xa1, 0x12, 0xd7,
	0xfb, 0x41, 0x1c, 0x69, 0xbb, 0x22, 0x46, 0xa1, 0xf0, 0x5c, 0x58, 0x9d, 0xdc, 0x58, 0x75, 0xb2,
	0xe7, 0xeb, 0x53, 0x94, 0xe6, 0xb7, 0x33, 0xb2, 0x7f, 0xcf, 0x38, 0xa4, 0x63, 0x4c, 0xc5, 0xa1,
	0x4f, 0x61, 0xbe, 0xf8, 0x37, 0xc2, 0x34, 0x8f, 0xdc, 0xcc, 0xf9, 0xcb, 0x11, 0x4d, 0x47, 0xc3,
	0xdd, 0xdc, 0x01, 0x9b, 0xce, 0xd7, 0x52, 0x6a, 0xe7, 0xf0, 0xc5, 0x79, 0xdb, 0x7a, 0x79, 0xde,
	0xb6, 0xfe, 0x3d, 0x6f, 0x5b, 0xcf, 0x2f, 0xda, 0x33, 0x2f, 0x2f, 0xda, 0x33, 0xff, 0x5c, 0xb4,
	0x67, 0xbe, 0xbe, 0x3f, 0xed, 0x7f, 0xa6, 0x13, 0xf5, 0x5f, 0xed, 0x93, 0xff, 0x03, 0x00, 0x00,
	0xff, 0xff, 0x3d, 0x6f, 0x60, 0xfc, 0xc0, 0x0d, 0x00, 0x00,
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Err) > 0 {
		i -= len(m.Err)
		copy(dAtA[i:], m.Err)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Err)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchBlockHeaderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchBlockHeaderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchBlockHeaderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x22
	}
	if m.End != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchBlockHeaderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchBlockHeaderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchBlockHeaderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Block) > 0 {
		for iNdEx := len(m.Block) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Block[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSync(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NegotiateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NegotiateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NegotiateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockNegotiateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockNegotiateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockNegotiateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TargetHash) > 0 {
		i -= len(m.TargetHash)
		copy(dAtA[i:], m.TargetHash)
		i = encodeVarintSync(dAtA, i, uint64(len(m.TargetHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TargetHeight != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.TargetHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.ChainHeight != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.ChainHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NegotiateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NegotiateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NegotiateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Nonce != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockNegotiateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockNegotiateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockNegotiateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Epoch != nil {
		{
			size, err := m.Epoch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.TxVersion) > 0 {
		i -= len(m.TxVersion)
		copy(dAtA[i:], m.TxVersion)
		i = encodeVarintSync(dAtA, i, uint64(len(m.TxVersion)))
		i--
		dAtA[i] = 0x3a
	}
	if m.LowestSnapshot != nil {
		{
			size, err := m.LowestSnapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.HighestSnapshot != nil {
		{
			size, err := m.HighestSnapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VersionSplitTxRoot) > 0 {
		i -= len(m.VersionSplitTxRoot)
		copy(dAtA[i:], m.VersionSplitTxRoot)
		i = encodeVarintSync(dAtA, i, uint64(len(m.VersionSplitTxRoot)))
		i--
		dAtA[i] = 0x1a
	}
	if m.VersionSplit != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.VersionSplit))
		i--
		dAtA[i] = 0x10
	}
	if m.Genesis != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Genesis))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FilterID) > 0 {
		i -= len(m.FilterID)
		copy(dAtA[i:], m.FilterID)
		i = encodeVarintSync(dAtA, i, uint64(len(m.FilterID)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Size_ != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if m.InvalidTxNum != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.InvalidTxNum))
		i--
		dAtA[i] = 0x18
	}
	if m.TxNum != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.TxNum))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchGenesisRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchGenesisRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchGenesisRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchGenesisResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchGenesisResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchGenesisResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Height != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BJRPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BJRPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BJRPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ReceiptWrapper) > 0 {
		i -= len(m.ReceiptWrapper)
		copy(dAtA[i:], m.ReceiptWrapper)
		i = encodeVarintSync(dAtA, i, uint64(len(m.ReceiptWrapper)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Journal) > 0 {
		i -= len(m.Journal)
		copy(dAtA[i:], m.Journal)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Journal)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BlockWrapper) > 0 {
		i -= len(m.BlockWrapper)
		copy(dAtA[i:], m.BlockWrapper)
		i = encodeVarintSync(dAtA, i, uint64(len(m.BlockWrapper)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchHPCBlocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchHPCBlocksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchHPCBlocksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchHPCBlocksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchHPCBlocksResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchHPCBlocksResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BJR != nil {
		{
			size, err := m.BJR.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchLedgerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchLedgerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchLedgerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FilterID) > 0 {
		i -= len(m.FilterID)
		copy(dAtA[i:], m.FilterID)
		i = encodeVarintSync(dAtA, i, uint64(len(m.FilterID)))
		i--
		dAtA[i] = 0x22
	}
	if m.PartSize != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.PartSize))
		i--
		dAtA[i] = 0x18
	}
	if m.Position != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x10
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchLedgerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchLedgerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchLedgerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Position != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Checksum) > 0 {
		i -= len(m.Checksum)
		copy(dAtA[i:], m.Checksum)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Checksum)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ledger) > 0 {
		i -= len(m.Ledger)
		copy(dAtA[i:], m.Ledger)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Ledger)))
		i--
		dAtA[i] = 0x12
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NeedReceipt {
		i--
		if m.NeedReceipt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.NeedJournal {
		i--
		if m.NeedJournal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.End != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchBlockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchBlockResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchBlockResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Payload) > 0 {
		for iNdEx := len(m.Payload) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payload[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSync(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.Typ != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EpochMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.Typ != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EpochNegotiateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochNegotiateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochNegotiateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InitEpoch != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.InitEpoch))
		i--
		dAtA[i] = 0x10
	}
	if m.TargetEpoch != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.TargetEpoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EpochNegotiateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochNegotiateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochNegotiateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *FetchEpochRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchEpochRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchEpochRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchEpochResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchEpochResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchEpochResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Checkpoints) > 0 {
		for iNdEx := len(m.Checkpoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Checkpoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSync(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSync(dAtA []byte, offset int, v uint64) int {
	offset -= sovSync(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *TaskInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovSync(uint64(m.Nonce))
	}
	if m.Id != 0 {
		n += 1 + sovSync(uint64(m.Id))
	}
	return n
}

func (m *FetchBlockHeaderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovSync(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovSync(uint64(m.End))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *FetchBlockHeaderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if len(m.Block) > 0 {
		for _, e := range m.Block {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *NegotiateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovSync(uint64(m.Nonce))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *BlockNegotiateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainHeight != 0 {
		n += 1 + sovSync(uint64(m.ChainHeight))
	}
	if m.TargetHeight != 0 {
		n += 1 + sovSync(uint64(m.TargetHeight))
	}
	l = len(m.TargetHash)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *NegotiateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovSync(uint64(m.Nonce))
	}
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *BlockNegotiateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Genesis != 0 {
		n += 1 + sovSync(uint64(m.Genesis))
	}
	if m.VersionSplit != 0 {
		n += 1 + sovSync(uint64(m.VersionSplit))
	}
	l = len(m.VersionSplitTxRoot)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	if m.HighestSnapshot != nil {
		l = m.HighestSnapshot.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.LowestSnapshot != nil {
		l = m.LowestSnapshot.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	l = len(m.TxVersion)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Epoch != nil {
		l = m.Epoch.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *SnapshotInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovSync(uint64(m.Height))
	}
	if m.TxNum != 0 {
		n += 1 + sovSync(uint64(m.TxNum))
	}
	if m.InvalidTxNum != 0 {
		n += 1 + sovSync(uint64(m.InvalidTxNum))
	}
	if m.Size_ != 0 {
		n += 1 + sovSync(uint64(m.Size_))
	}
	l = len(m.FilterID)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *FetchGenesisRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovSync(uint64(m.Height))
	}
	return n
}

func (m *FetchGenesisResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovSync(uint64(m.Height))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *BJRPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockWrapper)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	l = len(m.ReceiptWrapper)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovSync(uint64(m.Number))
	}
	return n
}

func (m *FetchHPCBlocksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovSync(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovSync(uint64(m.End))
	}
	return n
}

func (m *FetchHPCBlocksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.BJR != nil {
		l = m.BJR.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *FetchLedgerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovSync(uint64(m.Position))
	}
	if m.PartSize != 0 {
		n += 1 + sovSync(uint64(m.PartSize))
	}
	l = len(m.FilterID)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *FetchLedgerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	l = len(m.Ledger)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	l = len(m.Checksum)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovSync(uint64(m.Position))
	}
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *FetchBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovSync(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovSync(uint64(m.End))
	}
	if m.NeedJournal {
		n += 2
	}
	if m.NeedReceipt {
		n += 2
	}
	return n
}

func (m *FetchBlockResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if len(m.Payload) > 0 {
		for _, e := range m.Payload {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *SyncMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovSync(uint64(m.Typ))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *EpochMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovSync(uint64(m.Typ))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *EpochNegotiateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetEpoch != 0 {
		n += 1 + sovSync(uint64(m.TargetEpoch))
	}
	if m.InitEpoch != 0 {
		n += 1 + sovSync(uint64(m.InitEpoch))
	}
	return n
}

func (m *EpochNegotiateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FetchEpochRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovSync(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovSync(uint64(m.End))
	}
	return n
}

func (m *FetchEpochResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if len(m.Checkpoints) > 0 {
		for _, e := range m.Checkpoints {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func sovSync(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSync(x uint64) (n int) {
	return sovSync(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchBlockHeaderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchBlockHeaderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchBlockHeaderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TaskInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchBlockHeaderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchBlockHeaderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchBlockHeaderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TaskInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Block = append(m.Block, &Block{})
			if err := m.Block[len(m.Block)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &Error{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NegotiateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NegotiateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NegotiateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockNegotiateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockNegotiateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockNegotiateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainHeight", wireType)
			}
			m.ChainHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetHeight", wireType)
			}
			m.TargetHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetHash = append(m.TargetHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TargetHash == nil {
				m.TargetHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NegotiateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NegotiateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NegotiateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &Error{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockNegotiateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockNegotiateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockNegotiateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			m.Genesis = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Genesis |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionSplit", wireType)
			}
			m.VersionSplit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionSplit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionSplitTxRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionSplitTxRoot = append(m.VersionSplitTxRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.VersionSplitTxRoot == nil {
				m.VersionSplitTxRoot = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestSnapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HighestSnapshot == nil {
				m.HighestSnapshot = &SnapshotInfo{}
			}
			if err := m.HighestSnapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowestSnapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LowestSnapshot == nil {
				m.LowestSnapshot = &SnapshotInfo{}
			}
			if err := m.LowestSnapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Epoch == nil {
				m.Epoch = &EpochInfo{}
			}
			if err := m.Epoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxNum", wireType)
			}
			m.TxNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidTxNum", wireType)
			}
			m.InvalidTxNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvalidTxNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchGenesisRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchGenesisRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchGenesisRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TaskInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchGenesisResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchGenesisResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchGenesisResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TaskInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &BJRPacket{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &Error{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BJRPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BJRPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BJRPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockWrapper", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockWrapper = append(m.BlockWrapper[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockWrapper == nil {
				m.BlockWrapper = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = append(m.Journal[:0], dAtA[iNdEx:postIndex]...)
			if m.Journal == nil {
				m.Journal = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiptWrapper", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReceiptWrapper = append(m.ReceiptWrapper[:0], dAtA[iNdEx:postIndex]...)
			if m.ReceiptWrapper == nil {
				m.ReceiptWrapper = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchHPCBlocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchHPCBlocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchHPCBlocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TaskInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchHPCBlocksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchHPCBlocksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchHPCBlocksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TaskInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BJR", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BJR == nil {
				m.BJR = &BJRPacket{}
			}
			if err := m.BJR.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &Error{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchLedgerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchLedgerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchLedgerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TaskInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartSize", wireType)
			}
			m.PartSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchLedgerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchLedgerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchLedgerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TaskInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ledger", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ledger = append(m.Ledger[:0], dAtA[iNdEx:postIndex]...)
			if m.Ledger == nil {
				m.Ledger = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = append(m.Checksum[:0], dAtA[iNdEx:postIndex]...)
			if m.Checksum == nil {
				m.Checksum = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &Error{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TaskInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedJournal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedJournal = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedReceipt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedReceipt = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchBlockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchBlockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchBlockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TaskInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, &BJRPacket{})
			if err := m.Payload[len(m.Payload)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &Error{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= SyncMsg_Typ(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= EpochMsg_Typ(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochNegotiateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochNegotiateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochNegotiateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetEpoch", wireType)
			}
			m.TargetEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitEpoch", wireType)
			}
			m.InitEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochNegotiateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochNegotiateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochNegotiateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchEpochRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchEpochRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchEpochRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TaskInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchEpochResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchEpochResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchEpochResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TaskInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checkpoints = append(m.Checkpoints, &QuorumCheckpoint{})
			if err := m.Checkpoints[len(m.Checkpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &Error{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSync(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSync
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSync
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSync
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSync
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthSync
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSync
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSync(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthSync
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSync = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSync   = fmt.Errorf("proto: integer overflow")
)
