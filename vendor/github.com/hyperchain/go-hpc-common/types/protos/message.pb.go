// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: message.proto

package protos

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type SessionMessage_Type int32

const (
	SessionMessage_NODE_STATE_REQUEST   SessionMessage_Type = 0
	SessionMessage_NODE_STATE_RESPONSE  SessionMessage_Type = 1
	SessionMessage_REMOVE_VP            SessionMessage_Type = 2
	SessionMessage_REMOVE_NVP           SessionMessage_Type = 3
	SessionMessage_NVP_UPGRADE          SessionMessage_Type = 4
	SessionMessage_RBFT_MESSAGE         SessionMessage_Type = 5
	SessionMessage_RAFT_MESSAGE         SessionMessage_Type = 6
	SessionMessage_RAFT_SERVICE_MESSAGE SessionMessage_Type = 7
	SessionMessage_PEER_POOL_MESSAGE    SessionMessage_Type = 8
	// sync_chain new version messgae
	SessionMessage_EXEC_SNYC_CHAIN      SessionMessage_Type = 9
	SessionMessage_EXEC_UNICAST_INVALID SessionMessage_Type = 10
	SessionMessage_EXEC_SYNC_COMMIT     SessionMessage_Type = 11
	// nvp
	SessionMessage_NVP_MESSAGE SessionMessage_Type = 12
	SessionMessage_NVP_RELAY   SessionMessage_Type = 13
	// Cert handshake
	SessionMessage_REQUESTENTER SessionMessage_Type = 17
	SessionMessage_ENTERREJECT  SessionMessage_Type = 18
	SessionMessage_CLIENTCERT   SessionMessage_Type = 19
	SessionMessage_SERVERCERT   SessionMessage_Type = 20
	SessionMessage_CLIENTDONE   SessionMessage_Type = 21
	// cvp
	SessionMessage_CVP_BLOCKPROCESS SessionMessage_Type = 22
	SessionMessage_CVP_COMMAND      SessionMessage_Type = 23
	// Azolla
	SessionMessage_NOXBFT_MESSAGE     SessionMessage_Type = 24
	SessionMessage_MEMPOOL_MESSAGE    SessionMessage_Type = 25
	SessionMessage_STATE_SYNC_MESSAGE SessionMessage_Type = 26
	// vp
	SessionMessage_TX_RELAY SessionMessage_Type = 27
)

var SessionMessage_Type_name = map[int32]string{
	0:  "NODE_STATE_REQUEST",
	1:  "NODE_STATE_RESPONSE",
	2:  "REMOVE_VP",
	3:  "REMOVE_NVP",
	4:  "NVP_UPGRADE",
	5:  "RBFT_MESSAGE",
	6:  "RAFT_MESSAGE",
	7:  "RAFT_SERVICE_MESSAGE",
	8:  "PEER_POOL_MESSAGE",
	9:  "EXEC_SNYC_CHAIN",
	10: "EXEC_UNICAST_INVALID",
	11: "EXEC_SYNC_COMMIT",
	12: "NVP_MESSAGE",
	13: "NVP_RELAY",
	17: "REQUESTENTER",
	18: "ENTERREJECT",
	19: "CLIENTCERT",
	20: "SERVERCERT",
	21: "CLIENTDONE",
	22: "CVP_BLOCKPROCESS",
	23: "CVP_COMMAND",
	24: "NOXBFT_MESSAGE",
	25: "MEMPOOL_MESSAGE",
	26: "STATE_SYNC_MESSAGE",
	27: "TX_RELAY",
}

var SessionMessage_Type_value = map[string]int32{
	"NODE_STATE_REQUEST":   0,
	"NODE_STATE_RESPONSE":  1,
	"REMOVE_VP":            2,
	"REMOVE_NVP":           3,
	"NVP_UPGRADE":          4,
	"RBFT_MESSAGE":         5,
	"RAFT_MESSAGE":         6,
	"RAFT_SERVICE_MESSAGE": 7,
	"PEER_POOL_MESSAGE":    8,
	"EXEC_SNYC_CHAIN":      9,
	"EXEC_UNICAST_INVALID": 10,
	"EXEC_SYNC_COMMIT":     11,
	"NVP_MESSAGE":          12,
	"NVP_RELAY":            13,
	"REQUESTENTER":         17,
	"ENTERREJECT":          18,
	"CLIENTCERT":           19,
	"SERVERCERT":           20,
	"CLIENTDONE":           21,
	"CVP_BLOCKPROCESS":     22,
	"CVP_COMMAND":          23,
	"NOXBFT_MESSAGE":       24,
	"MEMPOOL_MESSAGE":      25,
	"STATE_SYNC_MESSAGE":   26,
	"TX_RELAY":             27,
}

func (x SessionMessage_Type) String() string {
	return proto.EnumName(SessionMessage_Type_name, int32(x))
}

func (SessionMessage_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{0, 0}
}

type PeerMessage_Type int32

const (
	// refactored nvp
	PeerMessage_PEER_BLOCK              PeerMessage_Type = 0
	PeerMessage_PEER_BLOCK_ACK          PeerMessage_Type = 1
	PeerMessage_PEER_ROLLBACK           PeerMessage_Type = 2
	PeerMessage_PEER_ROLLBACK_ACK       PeerMessage_Type = 3
	PeerMessage_PEER_CHECKPOINT         PeerMessage_Type = 4
	PeerMessage_PEER_PING               PeerMessage_Type = 5
	PeerMessage_PEER_PONG               PeerMessage_Type = 6
	PeerMessage_PEER_HANDSHAKE          PeerMessage_Type = 7
	PeerMessage_PEER_HANDSHAKE_RESP     PeerMessage_Type = 8
	PeerMessage_PEER_LEDGER_PACKET      PeerMessage_Type = 9
	PeerMessage_PEER_LEDGER_PACKET_ACK  PeerMessage_Type = 10
	PeerMessage_PEER_GENESIS            PeerMessage_Type = 11
	PeerMessage_PEER_DISCONNECT         PeerMessage_Type = 12
	PeerMessage_PEER_DISCONNECT_ACK     PeerMessage_Type = 13
	PeerMessage_PEER_CVP_PING           PeerMessage_Type = 14
	PeerMessage_PEER_CVP_PONG           PeerMessage_Type = 15
	PeerMessage_PEER_CVP_HANDSHAKE      PeerMessage_Type = 16
	PeerMessage_PEER_CVP_HANDSHAKE_RESP PeerMessage_Type = 17
	PeerMessage_PEER_CVP_CMD            PeerMessage_Type = 18
	PeerMessage_PEER_CVP_CMD_RESP       PeerMessage_Type = 19
	PeerMessage_PEER_HPC_BLOCK          PeerMessage_Type = 20
	PeerMessage_PEER_HPC_BLOCK_ACK      PeerMessage_Type = 21
	PeerMessage_PEER_QC                 PeerMessage_Type = 22
	PeerMessage_PEER_QC_ACK             PeerMessage_Type = 23
)

var PeerMessage_Type_name = map[int32]string{
	0:  "PEER_BLOCK",
	1:  "PEER_BLOCK_ACK",
	2:  "PEER_ROLLBACK",
	3:  "PEER_ROLLBACK_ACK",
	4:  "PEER_CHECKPOINT",
	5:  "PEER_PING",
	6:  "PEER_PONG",
	7:  "PEER_HANDSHAKE",
	8:  "PEER_HANDSHAKE_RESP",
	9:  "PEER_LEDGER_PACKET",
	10: "PEER_LEDGER_PACKET_ACK",
	11: "PEER_GENESIS",
	12: "PEER_DISCONNECT",
	13: "PEER_DISCONNECT_ACK",
	14: "PEER_CVP_PING",
	15: "PEER_CVP_PONG",
	16: "PEER_CVP_HANDSHAKE",
	17: "PEER_CVP_HANDSHAKE_RESP",
	18: "PEER_CVP_CMD",
	19: "PEER_CVP_CMD_RESP",
	20: "PEER_HPC_BLOCK",
	21: "PEER_HPC_BLOCK_ACK",
	22: "PEER_QC",
	23: "PEER_QC_ACK",
}

var PeerMessage_Type_value = map[string]int32{
	"PEER_BLOCK":              0,
	"PEER_BLOCK_ACK":          1,
	"PEER_ROLLBACK":           2,
	"PEER_ROLLBACK_ACK":       3,
	"PEER_CHECKPOINT":         4,
	"PEER_PING":               5,
	"PEER_PONG":               6,
	"PEER_HANDSHAKE":          7,
	"PEER_HANDSHAKE_RESP":     8,
	"PEER_LEDGER_PACKET":      9,
	"PEER_LEDGER_PACKET_ACK":  10,
	"PEER_GENESIS":            11,
	"PEER_DISCONNECT":         12,
	"PEER_DISCONNECT_ACK":     13,
	"PEER_CVP_PING":           14,
	"PEER_CVP_PONG":           15,
	"PEER_CVP_HANDSHAKE":      16,
	"PEER_CVP_HANDSHAKE_RESP": 17,
	"PEER_CVP_CMD":            18,
	"PEER_CVP_CMD_RESP":       19,
	"PEER_HPC_BLOCK":          20,
	"PEER_HPC_BLOCK_ACK":      21,
	"PEER_QC":                 22,
	"PEER_QC_ACK":             23,
}

func (x PeerMessage_Type) String() string {
	return proto.EnumName(PeerMessage_Type_name, int32(x))
}

func (PeerMessage_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{1, 0}
}

type SyncChainMessage_Type int32

const (
	SyncChainMessage_BLOCK_HEADER_REQUEST  SyncChainMessage_Type = 0
	SyncChainMessage_BLOCK_HEADER_RESPONSE SyncChainMessage_Type = 1
	SyncChainMessage_BLOCK_REQUEST         SyncChainMessage_Type = 2
)

var SyncChainMessage_Type_name = map[int32]string{
	0: "BLOCK_HEADER_REQUEST",
	1: "BLOCK_HEADER_RESPONSE",
	2: "BLOCK_REQUEST",
}

var SyncChainMessage_Type_value = map[string]int32{
	"BLOCK_HEADER_REQUEST":  0,
	"BLOCK_HEADER_RESPONSE": 1,
	"BLOCK_REQUEST":         2,
}

func (x SyncChainMessage_Type) String() string {
	return proto.EnumName(SyncChainMessage_Type_name, int32(x))
}

func (SyncChainMessage_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{2, 0}
}

// This message type is used between consensus and outside
type SessionMessage struct {
	Type    SessionMessage_Type `protobuf:"varint,1,opt,name=type,proto3,enum=protos.SessionMessage_Type" json:"type,omitempty"`
	Payload []byte              `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SessionMessage) Reset()         { *m = SessionMessage{} }
func (m *SessionMessage) String() string { return proto.CompactTextString(m) }
func (*SessionMessage) ProtoMessage()    {}
func (*SessionMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{0}
}
func (m *SessionMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionMessage.Merge(m, src)
}
func (m *SessionMessage) XXX_Size() int {
	return m.Size()
}
func (m *SessionMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SessionMessage proto.InternalMessageInfo

func (m *SessionMessage) GetType() SessionMessage_Type {
	if m != nil {
		return m.Type
	}
	return SessionMessage_NODE_STATE_REQUEST
}

func (m *SessionMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type PeerMessage struct {
	Type      PeerMessage_Type `protobuf:"varint,1,opt,name=type,proto3,enum=protos.PeerMessage_Type" json:"type,omitempty"`
	Payload   []byte           `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	Namespace string           `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *PeerMessage) Reset()         { *m = PeerMessage{} }
func (m *PeerMessage) String() string { return proto.CompactTextString(m) }
func (*PeerMessage) ProtoMessage()    {}
func (*PeerMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{1}
}
func (m *PeerMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerMessage.Merge(m, src)
}
func (m *PeerMessage) XXX_Size() int {
	return m.Size()
}
func (m *PeerMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerMessage.DiscardUnknown(m)
}

var xxx_messageInfo_PeerMessage proto.InternalMessageInfo

func (m *PeerMessage) GetType() PeerMessage_Type {
	if m != nil {
		return m.Type
	}
	return PeerMessage_PEER_BLOCK
}

func (m *PeerMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *PeerMessage) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type SyncChainMessage struct {
	Type    SyncChainMessage_Type `protobuf:"varint,1,opt,name=type,proto3,enum=protos.SyncChainMessage_Type" json:"type,omitempty"`
	Payload []byte                `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SyncChainMessage) Reset()         { *m = SyncChainMessage{} }
func (m *SyncChainMessage) String() string { return proto.CompactTextString(m) }
func (*SyncChainMessage) ProtoMessage()    {}
func (*SyncChainMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{2}
}
func (m *SyncChainMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncChainMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncChainMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncChainMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncChainMessage.Merge(m, src)
}
func (m *SyncChainMessage) XXX_Size() int {
	return m.Size()
}
func (m *SyncChainMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncChainMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SyncChainMessage proto.InternalMessageInfo

func (m *SyncChainMessage) GetType() SyncChainMessage_Type {
	if m != nil {
		return m.Type
	}
	return SyncChainMessage_BLOCK_HEADER_REQUEST
}

func (m *SyncChainMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func init() {
	proto.RegisterEnum("protos.SessionMessage_Type", SessionMessage_Type_name, SessionMessage_Type_value)
	proto.RegisterEnum("protos.PeerMessage_Type", PeerMessage_Type_name, PeerMessage_Type_value)
	proto.RegisterEnum("protos.SyncChainMessage_Type", SyncChainMessage_Type_name, SyncChainMessage_Type_value)
	proto.RegisterType((*SessionMessage)(nil), "protos.SessionMessage")
	proto.RegisterType((*PeerMessage)(nil), "protos.PeerMessage")
	proto.RegisterType((*SyncChainMessage)(nil), "protos.SyncChainMessage")
}

func init() { proto.RegisterFile("message.proto", fileDescriptor_33c57e4bae7b9afd) }

var fileDescriptor_33c57e4bae7b9afd = []byte{
	// 782 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xcd, 0x52, 0xe3, 0x46,
	0x10, 0xc7, 0x2d, 0xf0, 0x02, 0x6e, 0x7f, 0x30, 0x1e, 0x1b, 0xac, 0x5d, 0x12, 0x17, 0xe5, 0x13,
	0x87, 0x2c, 0xce, 0xc7, 0x13, 0x88, 0x51, 0xc7, 0xd6, 0x5a, 0x1a, 0x69, 0x67, 0x84, 0x0b, 0x72,
	0x51, 0x79, 0x1d, 0x15, 0x50, 0x15, 0x23, 0x17, 0x22, 0x07, 0xbf, 0x45, 0xde, 0x24, 0xaf, 0xb1,
	0xc7, 0x3d, 0xe6, 0x98, 0x82, 0x5b, 0x2a, 0xe7, 0x9c, 0x53, 0x33, 0xb2, 0xc6, 0x78, 0xf7, 0xb2,
	0x27, 0xbb, 0x7f, 0xdd, 0x9a, 0xe9, 0x7f, 0xcf, 0xbf, 0x1a, 0x9a, 0x8b, 0x34, 0xcf, 0x67, 0x37,
	0xe9, 0xf9, 0xf2, 0x21, 0x7b, 0xcc, 0xe8, 0x9e, 0xfe, 0xc9, 0x07, 0x1f, 0xab, 0xd0, 0x92, 0x69,
	0x9e, 0xdf, 0x65, 0xf7, 0x41, 0x51, 0x40, 0x87, 0x50, 0x7d, 0x5c, 0x2d, 0x53, 0xdb, 0x3a, 0xb5,
	0xce, 0x5a, 0x3f, 0x9e, 0x14, 0x1f, 0xe4, 0xe7, 0xdb, 0x55, 0xe7, 0xf1, 0x6a, 0x99, 0x0a, 0x5d,
	0x48, 0x6d, 0xd8, 0x5f, 0xce, 0x56, 0xbf, 0x65, 0xb3, 0x5f, 0xed, 0x9d, 0x53, 0xeb, 0xac, 0x21,
	0xca, 0x70, 0xf0, 0xcf, 0x2e, 0x54, 0x55, 0x21, 0x3d, 0x06, 0xca, 0x43, 0x17, 0x13, 0x19, 0x3b,
	0x31, 0x26, 0x02, 0xdf, 0x5f, 0xa2, 0x8c, 0x49, 0x85, 0xf6, 0xa0, 0xb3, 0xc5, 0x65, 0x14, 0x72,
	0x89, 0xc4, 0xa2, 0x4d, 0xa8, 0x09, 0x0c, 0xc2, 0x29, 0x26, 0xd3, 0x88, 0xec, 0xd0, 0x16, 0xc0,
	0x3a, 0xe4, 0xd3, 0x88, 0xec, 0xd2, 0x43, 0xa8, 0xf3, 0x69, 0x94, 0x5c, 0x46, 0x23, 0xe1, 0xb8,
	0x48, 0xaa, 0x94, 0x40, 0x43, 0x5c, 0xfc, 0x1c, 0x27, 0x01, 0x4a, 0xe9, 0x8c, 0x90, 0xbc, 0xd2,
	0xc4, 0x79, 0x41, 0xf6, 0xa8, 0x0d, 0x5d, 0x4d, 0x24, 0x8a, 0xa9, 0xc7, 0xd0, 0x64, 0xf6, 0xe9,
	0x11, 0xb4, 0x23, 0x44, 0x91, 0x44, 0x61, 0xe8, 0x1b, 0x7c, 0x40, 0x3b, 0x70, 0x88, 0x57, 0xc8,
	0x12, 0xc9, 0xaf, 0x59, 0xc2, 0xc6, 0x8e, 0xc7, 0x49, 0x4d, 0x9d, 0xa2, 0xe1, 0x25, 0xf7, 0x98,
	0x23, 0xe3, 0xc4, 0xe3, 0x53, 0xc7, 0xf7, 0x5c, 0x02, 0xb4, 0x0b, 0xa4, 0x28, 0xbf, 0xe6, 0x2c,
	0x61, 0x61, 0x10, 0x78, 0x31, 0xa9, 0x97, 0xad, 0x96, 0xa7, 0x36, 0x94, 0x34, 0x05, 0x04, 0xfa,
	0xce, 0x35, 0x69, 0xea, 0x3e, 0x8b, 0x79, 0x20, 0x8f, 0x51, 0x90, 0xb6, 0xfa, 0x42, 0xff, 0x15,
	0xf8, 0x0e, 0x59, 0x4c, 0xa8, 0x52, 0xcf, 0x7c, 0x0f, 0x79, 0xcc, 0x50, 0xc4, 0xa4, 0xa3, 0x62,
	0xa5, 0x01, 0x85, 0x8e, 0xbb, 0x9b, 0xbc, 0x1b, 0x72, 0x24, 0x47, 0xaa, 0x11, 0x36, 0x8d, 0x92,
	0x0b, 0x3f, 0x64, 0x93, 0x48, 0x84, 0x0c, 0xa5, 0x24, 0xc7, 0xea, 0x58, 0x45, 0x55, 0x63, 0x0e,
	0x77, 0x49, 0x8f, 0x52, 0x68, 0xf1, 0xf0, 0xea, 0xe5, 0xd4, 0x6c, 0x25, 0x39, 0xc0, 0x60, 0x6b,
	0x0e, 0xaf, 0xd5, 0xeb, 0x15, 0x0f, 0xa4, 0x95, 0x95, 0xfc, 0x0d, 0x6d, 0xc0, 0x41, 0x7c, 0xb5,
	0x16, 0x72, 0x32, 0xf8, 0xb7, 0x0a, 0xf5, 0x28, 0x4d, 0x1f, 0x4a, 0x1f, 0x7d, 0xb7, 0xe5, 0x23,
	0xbb, 0xf4, 0xd1, 0x8b, 0x92, 0xaf, 0x32, 0x11, 0xfd, 0x06, 0x6a, 0xf7, 0xb3, 0x45, 0x9a, 0x2f,
	0x67, 0xf3, 0xd4, 0xde, 0x3d, 0xb5, 0xce, 0x6a, 0x62, 0x03, 0x06, 0xff, 0x95, 0x16, 0x6b, 0x01,
	0xe8, 0x37, 0xd4, 0xaa, 0x49, 0x45, 0xa9, 0xdb, 0xc4, 0x89, 0xc3, 0x26, 0xc4, 0xa2, 0x6d, 0x68,
	0x6a, 0x26, 0x42, 0xdf, 0xbf, 0x50, 0x68, 0xc7, 0x3c, 0x7d, 0x89, 0x74, 0xe5, 0xae, 0x9a, 0x83,
	0xc6, 0x6c, 0x8c, 0x6c, 0x12, 0x85, 0x1e, 0x8f, 0x49, 0x55, 0xbd, 0x5c, 0x61, 0x13, 0x8f, 0x8f,
	0xc8, 0xab, 0x4d, 0x18, 0xf2, 0x11, 0xd9, 0x33, 0x17, 0x8e, 0x1d, 0xee, 0xca, 0xb1, 0x33, 0x51,
	0xc6, 0xea, 0x41, 0x67, 0x9b, 0x69, 0x8f, 0x93, 0x03, 0x35, 0x52, 0x9d, 0xf0, 0xd1, 0x1d, 0xa9,
	0x23, 0x1c, 0x36, 0xc1, 0x98, 0xd4, 0xe8, 0x1b, 0x38, 0xfe, 0x92, 0xeb, 0x9e, 0x40, 0x39, 0x45,
	0xe7, 0x46, 0xc8, 0x51, 0x7a, 0x92, 0xd4, 0x4d, 0x97, 0xae, 0x27, 0x59, 0xc8, 0xb9, 0x72, 0x4b,
	0xc3, 0xdc, 0xb9, 0x81, 0xfa, 0xfb, 0xa6, 0x51, 0xaf, 0x5c, 0xa0, 0x25, 0xb4, 0xb6, 0x91, 0x92,
	0x71, 0x68, 0x3a, 0x53, 0x68, 0x23, 0x85, 0xd0, 0x13, 0xe8, 0x7d, 0xc9, 0x0b, 0x39, 0x6d, 0xd3,
	0x9a, 0x36, 0x58, 0xe0, 0x12, 0x6a, 0xe6, 0xba, 0x26, 0x45, 0x61, 0x67, 0x33, 0xa4, 0x88, 0xad,
	0x5f, 0xaa, 0x6b, 0x6e, 0x34, 0x4c, 0xf7, 0x7b, 0x44, 0xeb, 0xb0, 0xaf, 0xf9, 0x7b, 0x56, 0xb8,
	0x77, 0x1d, 0xe8, 0x6c, 0x6f, 0xf0, 0xa7, 0x05, 0x44, 0xae, 0xee, 0xe7, 0xec, 0x76, 0x76, 0x67,
	0x76, 0xd7, 0x0f, 0x5b, 0x9e, 0xfb, 0xd6, 0xec, 0xae, 0xcf, 0xea, 0xbe, 0x6e, 0x7b, 0xf1, 0xb5,
	0xb3, 0x6c, 0xe8, 0x16, 0x6d, 0x8d, 0xd1, 0x71, 0x95, 0x55, 0xcc, 0xfa, 0x7a, 0x0d, 0x47, 0x9f,
	0x65, 0xcc, 0x02, 0x6b, 0x43, 0xb3, 0x48, 0x95, 0xd5, 0x3b, 0x17, 0xef, 0x3e, 0x3e, 0xf5, 0xad,
	0x4f, 0x4f, 0x7d, 0xeb, 0xef, 0xa7, 0xbe, 0xf5, 0xc7, 0x73, 0xbf, 0xf2, 0xe9, 0xb9, 0x5f, 0xf9,
	0xeb, 0xb9, 0x5f, 0xf9, 0xe5, 0xfb, 0x9b, 0xbb, 0xc7, 0xdb, 0xdf, 0x3f, 0x9c, 0xcf, 0xb3, 0xc5,
	0xf0, 0x76, 0xb5, 0x4c, 0x1f, 0xe6, 0xaa, 0xd9, 0xe1, 0x4d, 0xf6, 0xf6, 0x76, 0x39, 0x7f, 0x3b,
	0xcf, 0x16, 0x8b, 0xec, 0x7e, 0xa8, 0xba, 0xcd, 0x87, 0x85, 0xa2, 0x0f, 0xc5, 0xfe, 0xfe, 0xe9,
	0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc9, 0x65, 0xbd, 0xbe, 0xd7, 0x05, 0x00, 0x00,
}

func (m *SessionMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncChainMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncChainMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncChainMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SessionMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessage(uint64(m.Type))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *PeerMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessage(uint64(m.Type))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *SyncChainMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessage(uint64(m.Type))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SessionMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SessionMessage_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PeerMessage_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncChainMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncChainMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncChainMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SyncChainMessage_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthMessage
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMessage(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthMessage
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMessage = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage   = fmt.Errorf("proto: integer overflow")
)
