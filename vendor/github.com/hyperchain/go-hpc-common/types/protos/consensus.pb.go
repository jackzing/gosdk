// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus.proto

package protos

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Type of the block, including NORMAL,NIL,GENESIS,PROOF
type BlockData_Type int32

const (
	// Normal blocks are used for proposals
	BlockData_NORMAL BlockData_Type = 0
	// NIL blocks don't have authors or signatures: they're generated upon timeouts to fill in the
	// gaps in the rounds.
	BlockData_NIL BlockData_Type = 1
	// A genesis block is the first committed block in any epoch that is identically constructed on
	// all validators by any (potentially different) LedgerInfo that justifies the epoch change
	// from the previous epoch.  The genesis block is used as the the first root block of the
	// BlockTree for all epochs.
	BlockData_GENESIS BlockData_Type = 2
	// Config blocks are special proposal blocks, they allow two situations:
	//
	// 1. If it is the first config block and its parent is not a config block, then it needs to contain
	// config transaction (only allow one include currently).
	//
	// 2. If it is the child block of config blocks, then it must be an empty block.
	BlockData_CONFIG BlockData_Type = 3
	// Proof blocks are special empty blocks and used to enforce checkpoint generation.
	// The proposer proposal proof blocks if checkpoints have not been generated for a lone time.
	BlockData_PROOF BlockData_Type = 4
)

var BlockData_Type_name = map[int32]string{
	0: "NORMAL",
	1: "NIL",
	2: "GENESIS",
	3: "CONFIG",
	4: "PROOF",
}

var BlockData_Type_value = map[string]int32{
	"NORMAL":  0,
	"NIL":     1,
	"GENESIS": 2,
	"CONFIG":  3,
	"PROOF":   4,
}

func (x BlockData_Type) String() string {
	return proto.EnumName(BlockData_Type_name, int32(x))
}

func (BlockData_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56f0f2c53b3de771, []int{6, 0}
}

// This structure serves a dual purpose.
//
// First, if this structure is signed by 2f+1 validators it signifies the state of the ledger at
// given checkpoint -- it contains the ledger accumulator hash at that height which commits to
// all historical transactions. This structure may be expanded to include other information that
// is derived from that accumulator (e.g. the current time according to the time contract) to
// reduce the number of proofs a client must get.
//
// Second, the structure contains a `consensus_data_hash` value. This is the hash of an internal
// data structure that represents a block that is voted on in HotStuff. If 2f+1 signatures are
// gathered on the same ledger info that represents a Quorum Certificate (QC) on the consensus
// data.
type LedgerInfo struct {
	// Potential committed block info used in HotStuff consensus.
	CommitInfo *ConsensusBlockInfo `protobuf:"bytes,1,opt,name=commit_info,json=commitInfo,proto3" json:"commit_info,omitempty"`
	// Hash of consensus-specific data that is opaque to all parts of the system
	// other than consensus. This is needed to verify signatures because
	// consensus signing includes this hash.
	ConsensusDataHash string `protobuf:"bytes,2,opt,name=consensus_data_hash,json=consensusDataHash,proto3" json:"consensus_data_hash,omitempty"`
}

func (m *LedgerInfo) Reset()      { *m = LedgerInfo{} }
func (*LedgerInfo) ProtoMessage() {}
func (*LedgerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_56f0f2c53b3de771, []int{0}
}
func (m *LedgerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerInfo.Merge(m, src)
}
func (m *LedgerInfo) XXX_Size() int {
	return m.Size()
}
func (m *LedgerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerInfo proto.InternalMessageInfo

func (m *LedgerInfo) GetCommitInfo() *ConsensusBlockInfo {
	if m != nil {
		return m.CommitInfo
	}
	return nil
}

func (m *LedgerInfo) GetConsensusDataHash() string {
	if m != nil {
		return m.ConsensusDataHash
	}
	return ""
}

// This structure contains all the information needed for tracking a block
// without having access to the block. It assumes that the block is the
// last block executed within the ledger.
type ConsensusBlockInfo struct {
	// Epoch number corresponds to the set of validators that are active for this block.
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// The round of a block is an internal monotonically increasing counter used by Consensus
	// protocol.
	Round uint64 `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	// The identifier (hash) of the block.
	Id string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	// TODO(DH): use to track ledger height?
	Height uint64 `protobuf:"varint,4,opt,name=height,proto3" json:"height,omitempty"`
	// The timestamp this block was proposed by a proposer.
	TimestampNanos int64 `protobuf:"varint,5,opt,name=timestamp_nanos,json=timestampNanos,proto3" json:"timestamp_nanos,omitempty"`
	// An optional field containing the set of validators for the start of the next epoch
	Reconfiguration bool `protobuf:"varint,6,opt,name=reconfiguration,proto3" json:"reconfiguration,omitempty"`
	// An optional field records whether block is a proof block
	Proof bool `protobuf:"varint,7,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *ConsensusBlockInfo) Reset()      { *m = ConsensusBlockInfo{} }
func (*ConsensusBlockInfo) ProtoMessage() {}
func (*ConsensusBlockInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_56f0f2c53b3de771, []int{1}
}
func (m *ConsensusBlockInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusBlockInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusBlockInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusBlockInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusBlockInfo.Merge(m, src)
}
func (m *ConsensusBlockInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusBlockInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusBlockInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusBlockInfo proto.InternalMessageInfo

func (m *ConsensusBlockInfo) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ConsensusBlockInfo) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *ConsensusBlockInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ConsensusBlockInfo) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ConsensusBlockInfo) GetTimestampNanos() int64 {
	if m != nil {
		return m.TimestampNanos
	}
	return 0
}

func (m *ConsensusBlockInfo) GetReconfiguration() bool {
	if m != nil {
		return m.Reconfiguration
	}
	return false
}

func (m *ConsensusBlockInfo) GetProof() bool {
	if m != nil {
		return m.Proof
	}
	return false
}

// The validator node returns this structure which includes signatures
// from each validator to confirm the state.  The client needs to only pass
// back the LedgerInfo element since the validator node doesn't need to know
// the signatures again when the client performs a query, those are only there
// for the client to be able to verify the state
type LedgerInfoWithSignatures struct {
	// The validator is identified by its account address: in order to verify a signature
	// one needs to retrieve the public key of the validator for the given epoch.
	Signatures map[string][]byte `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// detailed ledger info.
	LedgerInfo *LedgerInfo `protobuf:"bytes,2,opt,name=ledger_info,json=ledgerInfo,proto3" json:"ledger_info,omitempty"`
}

func (m *LedgerInfoWithSignatures) Reset()      { *m = LedgerInfoWithSignatures{} }
func (*LedgerInfoWithSignatures) ProtoMessage() {}
func (*LedgerInfoWithSignatures) Descriptor() ([]byte, []int) {
	return fileDescriptor_56f0f2c53b3de771, []int{2}
}
func (m *LedgerInfoWithSignatures) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerInfoWithSignatures) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerInfoWithSignatures.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerInfoWithSignatures) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerInfoWithSignatures.Merge(m, src)
}
func (m *LedgerInfoWithSignatures) XXX_Size() int {
	return m.Size()
}
func (m *LedgerInfoWithSignatures) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerInfoWithSignatures.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerInfoWithSignatures proto.InternalMessageInfo

func (m *LedgerInfoWithSignatures) GetSignatures() map[string][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *LedgerInfoWithSignatures) GetLedgerInfo() *LedgerInfo {
	if m != nil {
		return m.LedgerInfo
	}
	return nil
}

// QuorumCert contains the quorum certified information of certain proposal.
type QuorumCert struct {
	// The vote information certified by the quorum.
	VoteData *VoteData `protobuf:"bytes,1,opt,name=vote_data,json=voteData,proto3" json:"vote_data,omitempty"`
	// LedgerInfo with at least 2f+1 signatures. The LedgerInfo's consensus data
	// hash is a digest that covers vote data hash.
	SignedLedgerInfo *LedgerInfoWithSignatures `protobuf:"bytes,2,opt,name=signed_ledger_info,json=signedLedgerInfo,proto3" json:"signed_ledger_info,omitempty"`
}

func (m *QuorumCert) Reset()      { *m = QuorumCert{} }
func (*QuorumCert) ProtoMessage() {}
func (*QuorumCert) Descriptor() ([]byte, []int) {
	return fileDescriptor_56f0f2c53b3de771, []int{3}
}
func (m *QuorumCert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuorumCert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuorumCert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuorumCert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuorumCert.Merge(m, src)
}
func (m *QuorumCert) XXX_Size() int {
	return m.Size()
}
func (m *QuorumCert) XXX_DiscardUnknown() {
	xxx_messageInfo_QuorumCert.DiscardUnknown(m)
}

var xxx_messageInfo_QuorumCert proto.InternalMessageInfo

func (m *QuorumCert) GetVoteData() *VoteData {
	if m != nil {
		return m.VoteData
	}
	return nil
}

func (m *QuorumCert) GetSignedLedgerInfo() *LedgerInfoWithSignatures {
	if m != nil {
		return m.SignedLedgerInfo
	}
	return nil
}

// VoteData keeps the information about the block, and its parent.
type VoteData struct {
	// Contains all the block information needed for voting for the proposed round.
	Proposed *ConsensusBlockInfo `protobuf:"bytes,1,opt,name=proposed,proto3" json:"proposed,omitempty"`
	// Contains all the block information for the parent for the proposed round.
	Parent *ConsensusBlockInfo `protobuf:"bytes,2,opt,name=parent,proto3" json:"parent,omitempty"`
}

func (m *VoteData) Reset()      { *m = VoteData{} }
func (*VoteData) ProtoMessage() {}
func (*VoteData) Descriptor() ([]byte, []int) {
	return fileDescriptor_56f0f2c53b3de771, []int{4}
}
func (m *VoteData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteData.Merge(m, src)
}
func (m *VoteData) XXX_Size() int {
	return m.Size()
}
func (m *VoteData) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteData.DiscardUnknown(m)
}

var xxx_messageInfo_VoteData proto.InternalMessageInfo

func (m *VoteData) GetProposed() *ConsensusBlockInfo {
	if m != nil {
		return m.Proposed
	}
	return nil
}

func (m *VoteData) GetParent() *ConsensusBlockInfo {
	if m != nil {
		return m.Parent
	}
	return nil
}

// InnerBlock has the core data of a consensus block that should be persistent when necessary.
// Each block must know the id of its parent and keep the QuorumCertificate to that parent.
type InnerBlock struct {
	// This block's id as a hash value
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The container for the actual block
	BlockData *BlockData `protobuf:"bytes,2,opt,name=block_data,json=blockData,proto3" json:"block_data,omitempty"`
	// Signature that the hash of this block has been authored by the owner of the
	// private key.
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *InnerBlock) Reset()      { *m = InnerBlock{} }
func (*InnerBlock) ProtoMessage() {}
func (*InnerBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_56f0f2c53b3de771, []int{5}
}
func (m *InnerBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InnerBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InnerBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InnerBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InnerBlock.Merge(m, src)
}
func (m *InnerBlock) XXX_Size() int {
	return m.Size()
}
func (m *InnerBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_InnerBlock.DiscardUnknown(m)
}

var xxx_messageInfo_InnerBlock proto.InternalMessageInfo

func (m *InnerBlock) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InnerBlock) GetBlockData() *BlockData {
	if m != nil {
		return m.BlockData
	}
	return nil
}

func (m *InnerBlock) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Block has the core data of a consensus block that should be persistent when necessary.
// Each block must know the id of its parent and keep the QuorumCertificate to that parent.
// Currently, we use batch-noxbft, in which proposed block should only contains payload
// (hash list of transactions) rather than transactions entries, as a result, we can save
// network bandwidth of proposers.
type BlockData struct {
	// Epoch number corresponds to the set of validators that are active for this block.
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// The round of a block is an internal monotonically increasing counter used by consensus
	// protocol.
	Round uint64 `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	// The approximate physical time a block is proposed by a proposer.
	// It makes the following guarantees:
	// 1. Time Monotonicity: Time is monotonically increasing in the block
	//    chain. (i.e. If H1 < H2, H1.Time < H2.Time).
	// 2. If a block of transactions B is agreed on with timestamp T, then at least f+1
	//    honest replicas think that T is in the past.  An honest replica will only vote
	//    on a block when its own clock >= timestamp T.
	// 3. If a block of transactions B is agreed on with timestamp T, then at least f+1 honest
	//    replicas saw the contents of B no later than T + delta for some delta.
	//    If T = 3:00 PM and delta is 10 minutes, then an honest replica would not have
	//    voted for B unless its clock was between 3:00 PM to 3:10 PM at the time the
	//    proposal was received.  After 3:10 PM, an honest replica would no longer vote
	//    on B, noting it was too far in the past.
	TimestampNanos int64 `protobuf:"varint,3,opt,name=timestamp_nanos,json=timestampNanos,proto3" json:"timestamp_nanos,omitempty"`
	// Parent block id of this block as a hash value (all zeros to indicate the
	// genesis block)
	ParentId string `protobuf:"bytes,4,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
	// Contains the quorum certified ancestor and whether the quorum certified
	// ancestor was voted on successfully
	QuorumCert *QuorumCert `protobuf:"bytes,5,opt,name=quorum_cert,json=quorumCert,proto3" json:"quorum_cert,omitempty"`
	// Payload of the proposed block (include transaction digest(s) for batch-noxbft protocol)
	Payload [][]byte `protobuf:"bytes,6,rep,name=payload,proto3" json:"payload,omitempty"`
	// Transactions of the proposed block which are matched payload digest(s)
	Transactions []*Transaction `protobuf:"bytes,7,rep,name=transactions,proto3" json:"transactions,omitempty"`
	// Author of the block that can be validated by the author's public key and
	// the signature
	Author string `protobuf:"bytes,8,opt,name=author,proto3" json:"author,omitempty"`
	// Type of the block, including NORMAL,NIL,GENESIS,PROOF
	BlockType BlockData_Type `protobuf:"varint,9,opt,name=block_type,json=blockType,proto3,enum=protos.BlockData_Type" json:"block_type,omitempty"`
}

func (m *BlockData) Reset()         { *m = BlockData{} }
func (m *BlockData) String() string { return proto.CompactTextString(m) }
func (*BlockData) ProtoMessage()    {}
func (*BlockData) Descriptor() ([]byte, []int) {
	return fileDescriptor_56f0f2c53b3de771, []int{6}
}
func (m *BlockData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockData.Merge(m, src)
}
func (m *BlockData) XXX_Size() int {
	return m.Size()
}
func (m *BlockData) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockData.DiscardUnknown(m)
}

var xxx_messageInfo_BlockData proto.InternalMessageInfo

func (m *BlockData) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *BlockData) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *BlockData) GetTimestampNanos() int64 {
	if m != nil {
		return m.TimestampNanos
	}
	return 0
}

func (m *BlockData) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *BlockData) GetQuorumCert() *QuorumCert {
	if m != nil {
		return m.QuorumCert
	}
	return nil
}

func (m *BlockData) GetPayload() [][]byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *BlockData) GetTransactions() []*Transaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

func (m *BlockData) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *BlockData) GetBlockType() BlockData_Type {
	if m != nil {
		return m.BlockType
	}
	return BlockData_NORMAL
}

func init() {
	proto.RegisterEnum("protos.BlockData_Type", BlockData_Type_name, BlockData_Type_value)
	proto.RegisterType((*LedgerInfo)(nil), "protos.LedgerInfo")
	proto.RegisterType((*ConsensusBlockInfo)(nil), "protos.ConsensusBlockInfo")
	proto.RegisterType((*LedgerInfoWithSignatures)(nil), "protos.LedgerInfoWithSignatures")
	proto.RegisterMapType((map[string][]byte)(nil), "protos.LedgerInfoWithSignatures.SignaturesEntry")
	proto.RegisterType((*QuorumCert)(nil), "protos.QuorumCert")
	proto.RegisterType((*VoteData)(nil), "protos.VoteData")
	proto.RegisterType((*InnerBlock)(nil), "protos.InnerBlock")
	proto.RegisterType((*BlockData)(nil), "protos.BlockData")
}

func init() { proto.RegisterFile("consensus.proto", fileDescriptor_56f0f2c53b3de771) }

var fileDescriptor_56f0f2c53b3de771 = []byte{
	// 790 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0xcf, 0xc4, 0x69, 0x12, 0xbf, 0x54, 0xad, 0x77, 0x16, 0xad, 0xac, 0x82, 0x82, 0xd5, 0x0b,
	0xbe, 0x34, 0xa9, 0xba, 0xe2, 0x8f, 0x16, 0x21, 0x44, 0x4b, 0x77, 0x09, 0x2a, 0xe9, 0x32, 0x5d,
	0x81, 0xc4, 0x25, 0x9a, 0xd8, 0x13, 0xdb, 0xda, 0x64, 0xc6, 0x3b, 0x1e, 0x57, 0x8a, 0x84, 0xc4,
	0x57, 0x80, 0x03, 0x12, 0x47, 0x3e, 0x0e, 0xc7, 0xbd, 0xc1, 0x11, 0xb5, 0x12, 0x9f, 0x03, 0xcd,
	0x8c, 0xed, 0x94, 0xed, 0x02, 0xdb, 0x93, 0xdf, 0xdf, 0xdf, 0xbc, 0xf7, 0xe6, 0xf7, 0xc6, 0xb0,
	0x1b, 0x09, 0x5e, 0x30, 0x5e, 0x94, 0xc5, 0x28, 0x97, 0x42, 0x09, 0xdc, 0x35, 0x9f, 0x62, 0xef,
	0x38, 0xc9, 0x54, 0x5a, 0xce, 0x47, 0x91, 0x58, 0x8d, 0xd3, 0x75, 0xce, 0x64, 0x94, 0xd2, 0x8c,
	0x8f, 0x13, 0x71, 0x90, 0xe6, 0xd1, 0x41, 0x24, 0x56, 0x2b, 0xc1, 0xc7, 0x6a, 0x9d, 0xb3, 0x62,
	0x6c, 0x33, 0xc6, 0x4a, 0x52, 0x5e, 0xd0, 0x48, 0x65, 0x82, 0x5b, 0xac, 0xbd, 0x83, 0x1b, 0x18,
	0x89, 0x48, 0x84, 0x8d, 0x9c, 0x97, 0x0b, 0xa3, 0x19, 0xc5, 0x48, 0x36, 0x7c, 0xff, 0x07, 0x80,
	0x33, 0x16, 0x27, 0x4c, 0x4e, 0xf8, 0x42, 0xe0, 0x8f, 0x61, 0xa0, 0x4f, 0xc9, 0xd4, 0x2c, 0xe3,
	0x0b, 0xe1, 0xa3, 0x00, 0x85, 0x83, 0xa3, 0x3d, 0x1b, 0x5a, 0x8c, 0x4e, 0xea, 0xb2, 0x8f, 0x97,
	0x22, 0x7a, 0xae, 0x13, 0x08, 0xd8, 0x70, 0x93, 0x3c, 0x82, 0xfb, 0x4d, 0x63, 0xb3, 0x98, 0x2a,
	0x3a, 0x4b, 0x69, 0x91, 0xfa, 0xed, 0x00, 0x85, 0x2e, 0xb9, 0xd7, 0xb8, 0x3e, 0xa7, 0x8a, 0x7e,
	0x41, 0x8b, 0xf4, 0x51, 0xe7, 0x97, 0x5f, 0xdf, 0x6d, 0xed, 0xff, 0x8e, 0x00, 0xdf, 0x06, 0xc6,
	0x6f, 0xc1, 0x16, 0xcb, 0x45, 0x94, 0x9a, 0x1a, 0x3a, 0xc4, 0x2a, 0xda, 0x2a, 0x45, 0xc9, 0x63,
	0x03, 0xda, 0x21, 0x56, 0xc1, 0x3b, 0xd0, 0xce, 0x62, 0xdf, 0x31, 0xe7, 0xb4, 0xb3, 0x18, 0x3f,
	0x80, 0x6e, 0xca, 0xb2, 0x24, 0x55, 0x7e, 0xc7, 0x84, 0x55, 0x1a, 0x7e, 0x0f, 0x76, 0x55, 0xb6,
	0x62, 0x85, 0xa2, 0xab, 0x7c, 0xc6, 0x29, 0x17, 0x85, 0xbf, 0x15, 0xa0, 0xd0, 0x21, 0x3b, 0x8d,
	0x79, 0xaa, 0xad, 0x38, 0x84, 0x5d, 0xc9, 0x22, 0xc1, 0x17, 0x59, 0x52, 0x4a, 0xaa, 0x87, 0xeb,
	0x77, 0x03, 0x14, 0xf6, 0xc9, 0xab, 0x66, 0x5d, 0x50, 0x2e, 0x85, 0x58, 0xf8, 0x3d, 0xe3, 0xb7,
	0x4a, 0xd5, 0xd9, 0x5f, 0x08, 0xfc, 0xcd, 0x6c, 0xbf, 0xcd, 0x54, 0x7a, 0x91, 0x25, 0x9c, 0xaa,
	0x52, 0xb2, 0x02, 0x3f, 0x05, 0x28, 0x1a, 0xcd, 0x47, 0x81, 0x13, 0x0e, 0x8e, 0x0e, 0xeb, 0x41,
	0xff, 0x5b, 0xd6, 0x68, 0x23, 0x9e, 0x72, 0x25, 0xd7, 0xe4, 0x06, 0x06, 0x7e, 0x08, 0x83, 0xa5,
	0xc9, 0xb3, 0x77, 0xd7, 0x36, 0x77, 0x87, 0x6f, 0x43, 0x12, 0x58, 0x36, 0xf2, 0xde, 0x27, 0xb0,
	0xfb, 0x0a, 0x26, 0xf6, 0xc0, 0x79, 0xce, 0xd6, 0x66, 0xee, 0x2e, 0xd1, 0xa2, 0x6e, 0xf2, 0x92,
	0x2e, 0x4b, 0x66, 0x30, 0xb7, 0x89, 0x55, 0x1e, 0xb5, 0x3f, 0x42, 0x55, 0xa3, 0x3f, 0x21, 0x80,
	0xaf, 0x4b, 0x21, 0xcb, 0xd5, 0x09, 0x93, 0x0a, 0x1f, 0x80, 0x7b, 0x29, 0x14, 0x33, 0x14, 0xa8,
	0x28, 0xe4, 0xd5, 0x65, 0x7c, 0x23, 0x14, 0xd3, 0x04, 0x20, 0xfd, 0xcb, 0x4a, 0xc2, 0x53, 0xc0,
	0xba, 0x0b, 0x16, 0xcf, 0x6e, 0x97, 0x1f, 0xfc, 0xdf, 0x44, 0x88, 0x67, 0x73, 0x37, 0xfe, 0xaa,
	0xa6, 0xef, 0xa1, 0x5f, 0x9f, 0x85, 0x3f, 0x80, 0x7e, 0x2e, 0x45, 0x2e, 0x0a, 0x16, 0xbf, 0x01,
	0xa5, 0x9b, 0x58, 0x7c, 0x04, 0xdd, 0x9c, 0x4a, 0xc6, 0x55, 0x55, 0xcd, 0x7f, 0x65, 0x55, 0x91,
	0xd5, 0xe9, 0x12, 0x60, 0xc2, 0x39, 0x93, 0xc6, 0x5f, 0xf1, 0x13, 0x35, 0xfc, 0x3c, 0x04, 0x98,
	0x6b, 0x87, 0x9d, 0x90, 0xc5, 0xbe, 0x57, 0x63, 0x9b, 0x14, 0x33, 0x22, 0x77, 0x5e, 0x8b, 0xf8,
	0x1d, 0x70, 0x9b, 0x9b, 0x36, 0x44, 0xdf, 0x26, 0x1b, 0x43, 0x75, 0xe6, 0xcf, 0x0e, 0xb8, 0x4d,
	0xf2, 0x9d, 0xf6, 0xe7, 0x35, 0x7b, 0xe1, 0xbc, 0x76, 0x2f, 0xde, 0x06, 0xd7, 0xb6, 0x39, 0xcb,
	0x62, 0xb3, 0x5b, 0x2e, 0xe9, 0x5b, 0xc3, 0x24, 0xd6, 0xfc, 0x7b, 0x61, 0x48, 0x30, 0x8b, 0x98,
	0x54, 0x66, 0xb3, 0x6e, 0xf0, 0x6f, 0xc3, 0x0f, 0x02, 0x2f, 0x36, 0x5c, 0xf1, 0xa1, 0x97, 0xd3,
	0xf5, 0x52, 0xd0, 0xd8, 0xef, 0x06, 0x4e, 0xb8, 0x4d, 0x6a, 0x15, 0x7f, 0x08, 0xdb, 0x37, 0x1e,
	0xb7, 0xc2, 0xef, 0x99, 0x15, 0xb9, 0x5f, 0xe3, 0x3d, 0xdb, 0xf8, 0xc8, 0x3f, 0x02, 0xf5, 0xf6,
	0xd3, 0x52, 0xa5, 0x42, 0xfa, 0x7d, 0x53, 0x61, 0xa5, 0xe1, 0xf7, 0xeb, 0xa9, 0xeb, 0x07, 0xd4,
	0x77, 0x03, 0x14, 0xee, 0x1c, 0x3d, 0xb8, 0x35, 0xf5, 0xd1, 0xb3, 0x75, 0xce, 0xaa, 0xd1, 0x6b,
	0x71, 0xff, 0x53, 0xe8, 0xe8, 0x2f, 0x06, 0xe8, 0x4e, 0xcf, 0xc9, 0x57, 0x9f, 0x9d, 0x79, 0x2d,
	0xdc, 0x03, 0x67, 0x3a, 0x39, 0xf3, 0x10, 0x1e, 0x40, 0xef, 0xc9, 0xe9, 0xf4, 0xf4, 0x62, 0x72,
	0xe1, 0xb5, 0x75, 0xc4, 0xc9, 0xf9, 0xf4, 0xf1, 0xe4, 0x89, 0xe7, 0x60, 0x17, 0xb6, 0x9e, 0x92,
	0xf3, 0xf3, 0xc7, 0x5e, 0xe7, 0xf8, 0xcb, 0xdf, 0xae, 0x86, 0xe8, 0xe5, 0xd5, 0x10, 0xfd, 0x79,
	0x35, 0x44, 0x3f, 0x5e, 0x0f, 0x5b, 0x2f, 0xaf, 0x87, 0xad, 0x3f, 0xae, 0x87, 0xad, 0xef, 0x0e,
	0xef, 0xfa, 0xdc, 0xcf, 0xed, 0x8f, 0xe2, 0xe1, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x0b, 0x34,
	0xe9, 0xa8, 0x42, 0x06, 0x00, 0x00,
}

func (m *LedgerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConsensusDataHash) > 0 {
		i -= len(m.ConsensusDataHash)
		copy(dAtA[i:], m.ConsensusDataHash)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.ConsensusDataHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.CommitInfo != nil {
		{
			size, err := m.CommitInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusBlockInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusBlockInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusBlockInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof {
		i--
		if m.Proof {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Reconfiguration {
		i--
		if m.Reconfiguration {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.TimestampNanos != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.TimestampNanos))
		i--
		dAtA[i] = 0x28
	}
	if m.Height != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Round != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Epoch != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerInfoWithSignatures) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerInfoWithSignatures) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerInfoWithSignatures) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LedgerInfo != nil {
		{
			size, err := m.LedgerInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signatures) > 0 {
		for k := range m.Signatures {
			v := m.Signatures[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintConsensus(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintConsensus(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintConsensus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QuorumCert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuorumCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuorumCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignedLedgerInfo != nil {
		{
			size, err := m.SignedLedgerInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.VoteData != nil {
		{
			size, err := m.VoteData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VoteData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Parent != nil {
		{
			size, err := m.Parent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Proposed != nil {
		{
			size, err := m.Proposed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InnerBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InnerBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InnerBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockData != nil {
		{
			size, err := m.BlockData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockType != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.BlockType))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Transactions) > 0 {
		for iNdEx := len(m.Transactions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transactions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintConsensus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Payload) > 0 {
		for iNdEx := len(m.Payload) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Payload[iNdEx])
			copy(dAtA[i:], m.Payload[iNdEx])
			i = encodeVarintConsensus(dAtA, i, uint64(len(m.Payload[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.QuorumCert != nil {
		{
			size, err := m.QuorumCert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x22
	}
	if m.TimestampNanos != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.TimestampNanos))
		i--
		dAtA[i] = 0x18
	}
	if m.Round != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Epoch != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintConsensus(dAtA []byte, offset int, v uint64) int {
	offset -= sovConsensus(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LedgerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommitInfo != nil {
		l = m.CommitInfo.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	l = len(m.ConsensusDataHash)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *ConsensusBlockInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovConsensus(uint64(m.Epoch))
	}
	if m.Round != 0 {
		n += 1 + sovConsensus(uint64(m.Round))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovConsensus(uint64(m.Height))
	}
	if m.TimestampNanos != 0 {
		n += 1 + sovConsensus(uint64(m.TimestampNanos))
	}
	if m.Reconfiguration {
		n += 2
	}
	if m.Proof {
		n += 2
	}
	return n
}

func (m *LedgerInfoWithSignatures) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for k, v := range m.Signatures {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovConsensus(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovConsensus(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovConsensus(uint64(mapEntrySize))
		}
	}
	if m.LedgerInfo != nil {
		l = m.LedgerInfo.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *QuorumCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteData != nil {
		l = m.VoteData.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.SignedLedgerInfo != nil {
		l = m.SignedLedgerInfo.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *VoteData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposed != nil {
		l = m.Proposed.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.Parent != nil {
		l = m.Parent.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *InnerBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.BlockData != nil {
		l = m.BlockData.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *BlockData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovConsensus(uint64(m.Epoch))
	}
	if m.Round != 0 {
		n += 1 + sovConsensus(uint64(m.Round))
	}
	if m.TimestampNanos != 0 {
		n += 1 + sovConsensus(uint64(m.TimestampNanos))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.QuorumCert != nil {
		l = m.QuorumCert.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	if len(m.Payload) > 0 {
		for _, b := range m.Payload {
			l = len(b)
			n += 1 + l + sovConsensus(uint64(l))
		}
	}
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovConsensus(uint64(l))
		}
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.BlockType != 0 {
		n += 1 + sovConsensus(uint64(m.BlockType))
	}
	return n
}

func sovConsensus(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozConsensus(x uint64) (n int) {
	return sovConsensus(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LedgerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitInfo == nil {
				m.CommitInfo = &ConsensusBlockInfo{}
			}
			if err := m.CommitInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusDataHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusDataHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusBlockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusBlockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusBlockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNanos", wireType)
			}
			m.TimestampNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reconfiguration", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reconfiguration = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Proof = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerInfoWithSignatures) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerInfoWithSignatures: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerInfoWithSignatures: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signatures == nil {
				m.Signatures = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConsensus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConsensus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConsensus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConsensus
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConsensus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthConsensus
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthConsensus
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConsensus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConsensus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Signatures[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LedgerInfo == nil {
				m.LedgerInfo = &LedgerInfo{}
			}
			if err := m.LedgerInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuorumCert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuorumCert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuorumCert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VoteData == nil {
				m.VoteData = &VoteData{}
			}
			if err := m.VoteData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedLedgerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedLedgerInfo == nil {
				m.SignedLedgerInfo = &LedgerInfoWithSignatures{}
			}
			if err := m.SignedLedgerInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proposed == nil {
				m.Proposed = &ConsensusBlockInfo{}
			}
			if err := m.Proposed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parent == nil {
				m.Parent = &ConsensusBlockInfo{}
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InnerBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InnerBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InnerBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockData == nil {
				m.BlockData = &BlockData{}
			}
			if err := m.BlockData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNanos", wireType)
			}
			m.TimestampNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuorumCert == nil {
				m.QuorumCert = &QuorumCert{}
			}
			if err := m.QuorumCert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, make([]byte, postIndex-iNdEx))
			copy(m.Payload[len(m.Payload)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Transaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockType", wireType)
			}
			m.BlockType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockType |= BlockData_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConsensus(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthConsensus
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthConsensus
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowConsensus
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipConsensus(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthConsensus
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthConsensus = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConsensus   = fmt.Errorf("proto: integer overflow")
)
