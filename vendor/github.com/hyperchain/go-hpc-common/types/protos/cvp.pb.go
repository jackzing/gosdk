// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cvp.proto

package protos

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type BatchSyncType int32

const (
	BatchSyncType_BJR   BatchSyncType = 0
	BatchSyncType_State BatchSyncType = 1
)

var BatchSyncType_name = map[int32]string{
	0: "BJR",
	1: "State",
}

var BatchSyncType_value = map[string]int32{
	"BJR":   0,
	"State": 1,
}

func (x BatchSyncType) String() string {
	return proto.EnumName(BatchSyncType_name, int32(x))
}

func (BatchSyncType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{0}
}

type CvpCmdMsg_CmdMsgType int32

const (
	CvpCmdMsg_CmdPing          CvpCmdMsg_CmdMsgType = 0
	CvpCmdMsg_CmdPong          CvpCmdMsg_CmdMsgType = 1
	CvpCmdMsg_CmdHandshake     CvpCmdMsg_CmdMsgType = 2
	CvpCmdMsg_CmdHandshakeResp CvpCmdMsg_CmdMsgType = 3
	CvpCmdMsg_Cmd              CvpCmdMsg_CmdMsgType = 4
	CvpCmdMsg_CmdResp          CvpCmdMsg_CmdMsgType = 5
)

var CvpCmdMsg_CmdMsgType_name = map[int32]string{
	0: "CmdPing",
	1: "CmdPong",
	2: "CmdHandshake",
	3: "CmdHandshakeResp",
	4: "Cmd",
	5: "CmdResp",
}

var CvpCmdMsg_CmdMsgType_value = map[string]int32{
	"CmdPing":          0,
	"CmdPong":          1,
	"CmdHandshake":     2,
	"CmdHandshakeResp": 3,
	"Cmd":              4,
	"CmdResp":          5,
}

func (x CvpCmdMsg_CmdMsgType) String() string {
	return proto.EnumName(CvpCmdMsg_CmdMsgType_name, int32(x))
}

func (CvpCmdMsg_CmdMsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{2, 0}
}

type CVPNsMsg_CVPNsMsgType int32

const (
	CVPNsMsg_BJRPing       CVPNsMsg_CVPNsMsgType = 0
	CVPNsMsg_BJRPong       CVPNsMsg_CVPNsMsgType = 1
	CVPNsMsg_VPCheckpoint  CVPNsMsg_CVPNsMsgType = 2
	CVPNsMsg_StateNegoReq  CVPNsMsg_CVPNsMsgType = 3
	CVPNsMsg_StateNegoResp CVPNsMsg_CVPNsMsgType = 4
	CVPNsMsg_FetchRequest  CVPNsMsg_CVPNsMsgType = 5
	CVPNsMsg_FetchResponse CVPNsMsg_CVPNsMsgType = 6
)

var CVPNsMsg_CVPNsMsgType_name = map[int32]string{
	0: "BJRPing",
	1: "BJRPong",
	2: "VPCheckpoint",
	3: "StateNegoReq",
	4: "StateNegoResp",
	5: "FetchRequest",
	6: "FetchResponse",
}

var CVPNsMsg_CVPNsMsgType_value = map[string]int32{
	"BJRPing":       0,
	"BJRPong":       1,
	"VPCheckpoint":  2,
	"StateNegoReq":  3,
	"StateNegoResp": 4,
	"FetchRequest":  5,
	"FetchResponse": 6,
}

func (x CVPNsMsg_CVPNsMsgType) String() string {
	return proto.EnumName(CVPNsMsg_CVPNsMsgType_name, int32(x))
}

func (CVPNsMsg_CVPNsMsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{13, 0}
}

type CvpConfCmdList struct {
	CvpConfCmds []*CvpConfCmd `protobuf:"bytes,1,rep,name=cvpConfCmds,proto3" json:"cvpConfCmds,omitempty"`
	Namespace   string        `protobuf:"bytes,2,opt,name=Namespace,proto3" json:"Namespace,omitempty"`
}

func (m *CvpConfCmdList) Reset()         { *m = CvpConfCmdList{} }
func (m *CvpConfCmdList) String() string { return proto.CompactTextString(m) }
func (*CvpConfCmdList) ProtoMessage()    {}
func (*CvpConfCmdList) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{0}
}
func (m *CvpConfCmdList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CvpConfCmdList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CvpConfCmdList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CvpConfCmdList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CvpConfCmdList.Merge(m, src)
}
func (m *CvpConfCmdList) XXX_Size() int {
	return m.Size()
}
func (m *CvpConfCmdList) XXX_DiscardUnknown() {
	xxx_messageInfo_CvpConfCmdList.DiscardUnknown(m)
}

var xxx_messageInfo_CvpConfCmdList proto.InternalMessageInfo

func (m *CvpConfCmdList) GetCvpConfCmds() []*CvpConfCmd {
	if m != nil {
		return m.CvpConfCmds
	}
	return nil
}

func (m *CvpConfCmdList) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type CvpConfCmd struct {
	Method string   `protobuf:"bytes,1,opt,name=Method,proto3" json:"Method,omitempty"`
	Key    string   `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	Params []string `protobuf:"bytes,3,rep,name=Params,proto3" json:"Params,omitempty"`
}

func (m *CvpConfCmd) Reset()         { *m = CvpConfCmd{} }
func (m *CvpConfCmd) String() string { return proto.CompactTextString(m) }
func (*CvpConfCmd) ProtoMessage()    {}
func (*CvpConfCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{1}
}
func (m *CvpConfCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CvpConfCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CvpConfCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CvpConfCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CvpConfCmd.Merge(m, src)
}
func (m *CvpConfCmd) XXX_Size() int {
	return m.Size()
}
func (m *CvpConfCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_CvpConfCmd.DiscardUnknown(m)
}

var xxx_messageInfo_CvpConfCmd proto.InternalMessageInfo

func (m *CvpConfCmd) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *CvpConfCmd) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *CvpConfCmd) GetParams() []string {
	if m != nil {
		return m.Params
	}
	return nil
}

type CvpCmdMsg struct {
	Type    CvpCmdMsg_CmdMsgType `protobuf:"varint,1,opt,name=type,proto3,enum=protos.CvpCmdMsg_CmdMsgType" json:"type,omitempty"`
	Payload []byte               `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *CvpCmdMsg) Reset()         { *m = CvpCmdMsg{} }
func (m *CvpCmdMsg) String() string { return proto.CompactTextString(m) }
func (*CvpCmdMsg) ProtoMessage()    {}
func (*CvpCmdMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{2}
}
func (m *CvpCmdMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CvpCmdMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CvpCmdMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CvpCmdMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CvpCmdMsg.Merge(m, src)
}
func (m *CvpCmdMsg) XXX_Size() int {
	return m.Size()
}
func (m *CvpCmdMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_CvpCmdMsg.DiscardUnknown(m)
}

var xxx_messageInfo_CvpCmdMsg proto.InternalMessageInfo

func (m *CvpCmdMsg) GetType() CvpCmdMsg_CmdMsgType {
	if m != nil {
		return m.Type
	}
	return CvpCmdMsg_CmdPing
}

func (m *CvpCmdMsg) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type CmdPing struct {
	View  uint64 `protobuf:"varint,1,opt,name=view,proto3" json:"view,omitempty"`
	CmdID uint64 `protobuf:"varint,2,opt,name=cmdID,proto3" json:"cmdID,omitempty"`
}

func (m *CmdPing) Reset()         { *m = CmdPing{} }
func (m *CmdPing) String() string { return proto.CompactTextString(m) }
func (*CmdPing) ProtoMessage()    {}
func (*CmdPing) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{3}
}
func (m *CmdPing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CmdPing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CmdPing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CmdPing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdPing.Merge(m, src)
}
func (m *CmdPing) XXX_Size() int {
	return m.Size()
}
func (m *CmdPing) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdPing.DiscardUnknown(m)
}

var xxx_messageInfo_CmdPing proto.InternalMessageInfo

func (m *CmdPing) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *CmdPing) GetCmdID() uint64 {
	if m != nil {
		return m.CmdID
	}
	return 0
}

type CmdPong struct {
	View uint64 `protobuf:"varint,1,opt,name=view,proto3" json:"view,omitempty"`
}

func (m *CmdPong) Reset()         { *m = CmdPong{} }
func (m *CmdPong) String() string { return proto.CompactTextString(m) }
func (*CmdPong) ProtoMessage()    {}
func (*CmdPong) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{4}
}
func (m *CmdPong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CmdPong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CmdPong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CmdPong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdPong.Merge(m, src)
}
func (m *CmdPong) XXX_Size() int {
	return m.Size()
}
func (m *CmdPong) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdPong.DiscardUnknown(m)
}

var xxx_messageInfo_CmdPong proto.InternalMessageInfo

func (m *CmdPong) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

type CmdHandshake struct {
	View   uint64 `protobuf:"varint,1,opt,name=view,proto3" json:"view,omitempty"`
	CmdID  uint64 `protobuf:"varint,2,opt,name=cmdID,proto3" json:"cmdID,omitempty"`
	Inited bool   `protobuf:"varint,3,opt,name=inited,proto3" json:"inited,omitempty"`
}

func (m *CmdHandshake) Reset()         { *m = CmdHandshake{} }
func (m *CmdHandshake) String() string { return proto.CompactTextString(m) }
func (*CmdHandshake) ProtoMessage()    {}
func (*CmdHandshake) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{5}
}
func (m *CmdHandshake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CmdHandshake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CmdHandshake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CmdHandshake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdHandshake.Merge(m, src)
}
func (m *CmdHandshake) XXX_Size() int {
	return m.Size()
}
func (m *CmdHandshake) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdHandshake.DiscardUnknown(m)
}

var xxx_messageInfo_CmdHandshake proto.InternalMessageInfo

func (m *CmdHandshake) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *CmdHandshake) GetCmdID() uint64 {
	if m != nil {
		return m.CmdID
	}
	return 0
}

func (m *CmdHandshake) GetInited() bool {
	if m != nil {
		return m.Inited
	}
	return false
}

type CmdHandshakeResp struct {
	Payload *CvpPayload   `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Check   *CvpConfCheck `protobuf:"bytes,2,opt,name=check,proto3" json:"check,omitempty"`
	CmdID   uint64        `protobuf:"varint,3,opt,name=cmdID,proto3" json:"cmdID,omitempty"`
	View    uint64        `protobuf:"varint,4,opt,name=view,proto3" json:"view,omitempty"`
}

func (m *CmdHandshakeResp) Reset()         { *m = CmdHandshakeResp{} }
func (m *CmdHandshakeResp) String() string { return proto.CompactTextString(m) }
func (*CmdHandshakeResp) ProtoMessage()    {}
func (*CmdHandshakeResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{6}
}
func (m *CmdHandshakeResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CmdHandshakeResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CmdHandshakeResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CmdHandshakeResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdHandshakeResp.Merge(m, src)
}
func (m *CmdHandshakeResp) XXX_Size() int {
	return m.Size()
}
func (m *CmdHandshakeResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdHandshakeResp.DiscardUnknown(m)
}

var xxx_messageInfo_CmdHandshakeResp proto.InternalMessageInfo

func (m *CmdHandshakeResp) GetPayload() *CvpPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *CmdHandshakeResp) GetCheck() *CvpConfCheck {
	if m != nil {
		return m.Check
	}
	return nil
}

func (m *CmdHandshakeResp) GetCmdID() uint64 {
	if m != nil {
		return m.CmdID
	}
	return 0
}

func (m *CmdHandshakeResp) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

type Cmd struct {
	Args    []string    `protobuf:"bytes,1,rep,name=args,proto3" json:"args,omitempty"`
	Undo    []string    `protobuf:"bytes,2,rep,name=undo,proto3" json:"undo,omitempty"`
	CmdID   uint64      `protobuf:"varint,3,opt,name=cmdID,proto3" json:"cmdID,omitempty"`
	Payload *CvpPayload `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Cmd) Reset()         { *m = Cmd{} }
func (m *Cmd) String() string { return proto.CompactTextString(m) }
func (*Cmd) ProtoMessage()    {}
func (*Cmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{7}
}
func (m *Cmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cmd.Merge(m, src)
}
func (m *Cmd) XXX_Size() int {
	return m.Size()
}
func (m *Cmd) XXX_DiscardUnknown() {
	xxx_messageInfo_Cmd.DiscardUnknown(m)
}

var xxx_messageInfo_Cmd proto.InternalMessageInfo

func (m *Cmd) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Cmd) GetUndo() []string {
	if m != nil {
		return m.Undo
	}
	return nil
}

func (m *Cmd) GetCmdID() uint64 {
	if m != nil {
		return m.CmdID
	}
	return 0
}

func (m *Cmd) GetPayload() *CvpPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type CmdResp struct {
	CmdID   uint64 `protobuf:"varint,1,opt,name=cmdID,proto3" json:"cmdID,omitempty"`
	Success bool   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	Msg     string `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *CmdResp) Reset()         { *m = CmdResp{} }
func (m *CmdResp) String() string { return proto.CompactTextString(m) }
func (*CmdResp) ProtoMessage()    {}
func (*CmdResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{8}
}
func (m *CmdResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CmdResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CmdResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CmdResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdResp.Merge(m, src)
}
func (m *CmdResp) XXX_Size() int {
	return m.Size()
}
func (m *CmdResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdResp.DiscardUnknown(m)
}

var xxx_messageInfo_CmdResp proto.InternalMessageInfo

func (m *CmdResp) GetCmdID() uint64 {
	if m != nil {
		return m.CmdID
	}
	return 0
}

func (m *CmdResp) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CmdResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type NamespacePayload struct {
	Certs    []byte            `protobuf:"bytes,1,opt,name=certs,proto3" json:"certs,omitempty"`
	NsConfig []byte            `protobuf:"bytes,2,opt,name=nsConfig,proto3" json:"nsConfig,omitempty"`
	Mq       map[string][]byte `protobuf:"bytes,3,rep,name=mq,proto3" json:"mq,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NamespacePayload) Reset()         { *m = NamespacePayload{} }
func (m *NamespacePayload) String() string { return proto.CompactTextString(m) }
func (*NamespacePayload) ProtoMessage()    {}
func (*NamespacePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{9}
}
func (m *NamespacePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespacePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespacePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespacePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespacePayload.Merge(m, src)
}
func (m *NamespacePayload) XXX_Size() int {
	return m.Size()
}
func (m *NamespacePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespacePayload.DiscardUnknown(m)
}

var xxx_messageInfo_NamespacePayload proto.InternalMessageInfo

func (m *NamespacePayload) GetCerts() []byte {
	if m != nil {
		return m.Certs
	}
	return nil
}

func (m *NamespacePayload) GetNsConfig() []byte {
	if m != nil {
		return m.NsConfig
	}
	return nil
}

func (m *NamespacePayload) GetMq() map[string][]byte {
	if m != nil {
		return m.Mq
	}
	return nil
}

type CvpPayload struct {
	SysConf        []byte                       `protobuf:"bytes,1,opt,name=sysConf,proto3" json:"sysConf,omitempty"`
	NsPayload      map[string]*NamespacePayload `protobuf:"bytes,2,rep,name=nsPayload,proto3" json:"nsPayload,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CvpConfCmdList *CvpConfCmdList              `protobuf:"bytes,3,opt,name=cvpConfCmdList,proto3" json:"cvpConfCmdList,omitempty"`
}

func (m *CvpPayload) Reset()         { *m = CvpPayload{} }
func (m *CvpPayload) String() string { return proto.CompactTextString(m) }
func (*CvpPayload) ProtoMessage()    {}
func (*CvpPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{10}
}
func (m *CvpPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CvpPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CvpPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CvpPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CvpPayload.Merge(m, src)
}
func (m *CvpPayload) XXX_Size() int {
	return m.Size()
}
func (m *CvpPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_CvpPayload.DiscardUnknown(m)
}

var xxx_messageInfo_CvpPayload proto.InternalMessageInfo

func (m *CvpPayload) GetSysConf() []byte {
	if m != nil {
		return m.SysConf
	}
	return nil
}

func (m *CvpPayload) GetNsPayload() map[string]*NamespacePayload {
	if m != nil {
		return m.NsPayload
	}
	return nil
}

func (m *CvpPayload) GetCvpConfCmdList() *CvpConfCmdList {
	if m != nil {
		return m.CvpConfCmdList
	}
	return nil
}

type CvpConfCheck struct {
	NsStatus map[string]bool                `protobuf:"bytes,1,rep,name=nsStatus,proto3" json:"nsStatus,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	NsCheck  map[string]*NamespaceConfCheck `protobuf:"bytes,2,rep,name=nsCheck,proto3" json:"nsCheck,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CvpConfCheck) Reset()         { *m = CvpConfCheck{} }
func (m *CvpConfCheck) String() string { return proto.CompactTextString(m) }
func (*CvpConfCheck) ProtoMessage()    {}
func (*CvpConfCheck) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{11}
}
func (m *CvpConfCheck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CvpConfCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CvpConfCheck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CvpConfCheck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CvpConfCheck.Merge(m, src)
}
func (m *CvpConfCheck) XXX_Size() int {
	return m.Size()
}
func (m *CvpConfCheck) XXX_DiscardUnknown() {
	xxx_messageInfo_CvpConfCheck.DiscardUnknown(m)
}

var xxx_messageInfo_CvpConfCheck proto.InternalMessageInfo

func (m *CvpConfCheck) GetNsStatus() map[string]bool {
	if m != nil {
		return m.NsStatus
	}
	return nil
}

func (m *CvpConfCheck) GetNsCheck() map[string]*NamespaceConfCheck {
	if m != nil {
		return m.NsCheck
	}
	return nil
}

type NamespaceConfCheck struct {
	EncryptBitmap uint32 `protobuf:"varint,1,opt,name=encryptBitmap,proto3" json:"encryptBitmap,omitempty"`
	IndexEnabled  bool   `protobuf:"varint,2,opt,name=indexEnabled,proto3" json:"indexEnabled,omitempty"`
	Layer2        []byte `protobuf:"bytes,3,opt,name=layer2,proto3" json:"layer2,omitempty"`
}

func (m *NamespaceConfCheck) Reset()         { *m = NamespaceConfCheck{} }
func (m *NamespaceConfCheck) String() string { return proto.CompactTextString(m) }
func (*NamespaceConfCheck) ProtoMessage()    {}
func (*NamespaceConfCheck) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{12}
}
func (m *NamespaceConfCheck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceConfCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespaceConfCheck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespaceConfCheck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceConfCheck.Merge(m, src)
}
func (m *NamespaceConfCheck) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceConfCheck) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceConfCheck.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceConfCheck proto.InternalMessageInfo

func (m *NamespaceConfCheck) GetEncryptBitmap() uint32 {
	if m != nil {
		return m.EncryptBitmap
	}
	return 0
}

func (m *NamespaceConfCheck) GetIndexEnabled() bool {
	if m != nil {
		return m.IndexEnabled
	}
	return false
}

func (m *NamespaceConfCheck) GetLayer2() []byte {
	if m != nil {
		return m.Layer2
	}
	return nil
}

// bjr related
type CVPNsMsg struct {
	NsName  string                `protobuf:"bytes,1,opt,name=nsName,proto3" json:"nsName,omitempty"`
	Typ     CVPNsMsg_CVPNsMsgType `protobuf:"varint,2,opt,name=typ,proto3,enum=protos.CVPNsMsg_CVPNsMsgType" json:"typ,omitempty"`
	Payload []byte                `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *CVPNsMsg) Reset()         { *m = CVPNsMsg{} }
func (m *CVPNsMsg) String() string { return proto.CompactTextString(m) }
func (*CVPNsMsg) ProtoMessage()    {}
func (*CVPNsMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{13}
}
func (m *CVPNsMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CVPNsMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CVPNsMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CVPNsMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CVPNsMsg.Merge(m, src)
}
func (m *CVPNsMsg) XXX_Size() int {
	return m.Size()
}
func (m *CVPNsMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_CVPNsMsg.DiscardUnknown(m)
}

var xxx_messageInfo_CVPNsMsg proto.InternalMessageInfo

func (m *CVPNsMsg) GetNsName() string {
	if m != nil {
		return m.NsName
	}
	return ""
}

func (m *CVPNsMsg) GetTyp() CVPNsMsg_CVPNsMsgType {
	if m != nil {
		return m.Typ
	}
	return CVPNsMsg_BJRPing
}

func (m *CVPNsMsg) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type BJRPing struct {
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Sender string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
}

func (m *BJRPing) Reset()         { *m = BJRPing{} }
func (m *BJRPing) String() string { return proto.CompactTextString(m) }
func (*BJRPing) ProtoMessage()    {}
func (*BJRPing) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{14}
}
func (m *BJRPing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BJRPing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BJRPing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BJRPing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BJRPing.Merge(m, src)
}
func (m *BJRPing) XXX_Size() int {
	return m.Size()
}
func (m *BJRPing) XXX_DiscardUnknown() {
	xxx_messageInfo_BJRPing.DiscardUnknown(m)
}

var xxx_messageInfo_BJRPing proto.InternalMessageInfo

func (m *BJRPing) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BJRPing) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type BJRPong struct {
	Height     uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Genesis    uint64 `protobuf:"varint,2,opt,name=genesis,proto3" json:"genesis,omitempty"`
	SnapshotID string `protobuf:"bytes,3,opt,name=snapshotID,proto3" json:"snapshotID,omitempty"`
}

func (m *BJRPong) Reset()         { *m = BJRPong{} }
func (m *BJRPong) String() string { return proto.CompactTextString(m) }
func (*BJRPong) ProtoMessage()    {}
func (*BJRPong) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{15}
}
func (m *BJRPong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BJRPong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BJRPong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BJRPong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BJRPong.Merge(m, src)
}
func (m *BJRPong) XXX_Size() int {
	return m.Size()
}
func (m *BJRPong) XXX_DiscardUnknown() {
	xxx_messageInfo_BJRPong.DiscardUnknown(m)
}

var xxx_messageInfo_BJRPong proto.InternalMessageInfo

func (m *BJRPong) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BJRPong) GetGenesis() uint64 {
	if m != nil {
		return m.Genesis
	}
	return 0
}

func (m *BJRPong) GetSnapshotID() string {
	if m != nil {
		return m.SnapshotID
	}
	return ""
}

type VPCheckpoint struct {
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *VPCheckpoint) Reset()         { *m = VPCheckpoint{} }
func (m *VPCheckpoint) String() string { return proto.CompactTextString(m) }
func (*VPCheckpoint) ProtoMessage()    {}
func (*VPCheckpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{16}
}
func (m *VPCheckpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCheckpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCheckpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCheckpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCheckpoint.Merge(m, src)
}
func (m *VPCheckpoint) XXX_Size() int {
	return m.Size()
}
func (m *VPCheckpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCheckpoint.DiscardUnknown(m)
}

var xxx_messageInfo_VPCheckpoint proto.InternalMessageInfo

func (m *VPCheckpoint) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type StateNegoReq struct {
	SnapshotID string `protobuf:"bytes,1,opt,name=snapshotID,proto3" json:"snapshotID,omitempty"`
	Sender     string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
}

func (m *StateNegoReq) Reset()         { *m = StateNegoReq{} }
func (m *StateNegoReq) String() string { return proto.CompactTextString(m) }
func (*StateNegoReq) ProtoMessage()    {}
func (*StateNegoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{17}
}
func (m *StateNegoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateNegoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateNegoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateNegoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateNegoReq.Merge(m, src)
}
func (m *StateNegoReq) XXX_Size() int {
	return m.Size()
}
func (m *StateNegoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StateNegoReq.DiscardUnknown(m)
}

var xxx_messageInfo_StateNegoReq proto.InternalMessageInfo

func (m *StateNegoReq) GetSnapshotID() string {
	if m != nil {
		return m.SnapshotID
	}
	return ""
}

func (m *StateNegoReq) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type StateNegoResp struct {
	ShardNum         uint64     `protobuf:"varint,1,opt,name=shardNum,proto3" json:"shardNum,omitempty"`
	SnapTxSum        uint64     `protobuf:"varint,2,opt,name=snapTxSum,proto3" json:"snapTxSum,omitempty"`
	EpochInfo        *EpochInfo `protobuf:"bytes,3,opt,name=epochInfo,proto3" json:"epochInfo,omitempty"`
	SnapInvalidTxSum uint64     `protobuf:"varint,4,opt,name=snapInvalidTxSum,proto3" json:"snapInvalidTxSum,omitempty"`
}

func (m *StateNegoResp) Reset()         { *m = StateNegoResp{} }
func (m *StateNegoResp) String() string { return proto.CompactTextString(m) }
func (*StateNegoResp) ProtoMessage()    {}
func (*StateNegoResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{18}
}
func (m *StateNegoResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateNegoResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateNegoResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateNegoResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateNegoResp.Merge(m, src)
}
func (m *StateNegoResp) XXX_Size() int {
	return m.Size()
}
func (m *StateNegoResp) XXX_DiscardUnknown() {
	xxx_messageInfo_StateNegoResp.DiscardUnknown(m)
}

var xxx_messageInfo_StateNegoResp proto.InternalMessageInfo

func (m *StateNegoResp) GetShardNum() uint64 {
	if m != nil {
		return m.ShardNum
	}
	return 0
}

func (m *StateNegoResp) GetSnapTxSum() uint64 {
	if m != nil {
		return m.SnapTxSum
	}
	return 0
}

func (m *StateNegoResp) GetEpochInfo() *EpochInfo {
	if m != nil {
		return m.EpochInfo
	}
	return nil
}

func (m *StateNegoResp) GetSnapInvalidTxSum() uint64 {
	if m != nil {
		return m.SnapInvalidTxSum
	}
	return 0
}

type BatchSyncRequest struct {
	Typ    BatchSyncType `protobuf:"varint,1,opt,name=typ,proto3,enum=protos.BatchSyncType" json:"typ,omitempty"`
	Start  uint64        `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	End    uint64        `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
	Sender string        `protobuf:"bytes,4,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *BatchSyncRequest) Reset()         { *m = BatchSyncRequest{} }
func (m *BatchSyncRequest) String() string { return proto.CompactTextString(m) }
func (*BatchSyncRequest) ProtoMessage()    {}
func (*BatchSyncRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{19}
}
func (m *BatchSyncRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSyncRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSyncRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSyncRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSyncRequest.Merge(m, src)
}
func (m *BatchSyncRequest) XXX_Size() int {
	return m.Size()
}
func (m *BatchSyncRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSyncRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSyncRequest proto.InternalMessageInfo

func (m *BatchSyncRequest) GetTyp() BatchSyncType {
	if m != nil {
		return m.Typ
	}
	return BatchSyncType_BJR
}

func (m *BatchSyncRequest) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *BatchSyncRequest) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *BatchSyncRequest) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type BatchSyncResponse struct {
	Typ     BatchSyncType `protobuf:"varint,1,opt,name=typ,proto3,enum=protos.BatchSyncType" json:"typ,omitempty"`
	Num     uint64        `protobuf:"varint,2,opt,name=num,proto3" json:"num,omitempty"`
	Payload []byte        `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	Extra   []byte        `protobuf:"bytes,4,opt,name=extra,proto3" json:"extra,omitempty"`
}

func (m *BatchSyncResponse) Reset()         { *m = BatchSyncResponse{} }
func (m *BatchSyncResponse) String() string { return proto.CompactTextString(m) }
func (*BatchSyncResponse) ProtoMessage()    {}
func (*BatchSyncResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_72d8e38e08c2fc5e, []int{20}
}
func (m *BatchSyncResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSyncResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSyncResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSyncResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSyncResponse.Merge(m, src)
}
func (m *BatchSyncResponse) XXX_Size() int {
	return m.Size()
}
func (m *BatchSyncResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSyncResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSyncResponse proto.InternalMessageInfo

func (m *BatchSyncResponse) GetTyp() BatchSyncType {
	if m != nil {
		return m.Typ
	}
	return BatchSyncType_BJR
}

func (m *BatchSyncResponse) GetNum() uint64 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *BatchSyncResponse) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *BatchSyncResponse) GetExtra() []byte {
	if m != nil {
		return m.Extra
	}
	return nil
}

func init() {
	proto.RegisterEnum("protos.BatchSyncType", BatchSyncType_name, BatchSyncType_value)
	proto.RegisterEnum("protos.CvpCmdMsg_CmdMsgType", CvpCmdMsg_CmdMsgType_name, CvpCmdMsg_CmdMsgType_value)
	proto.RegisterEnum("protos.CVPNsMsg_CVPNsMsgType", CVPNsMsg_CVPNsMsgType_name, CVPNsMsg_CVPNsMsgType_value)
	proto.RegisterType((*CvpConfCmdList)(nil), "protos.CvpConfCmdList")
	proto.RegisterType((*CvpConfCmd)(nil), "protos.CvpConfCmd")
	proto.RegisterType((*CvpCmdMsg)(nil), "protos.CvpCmdMsg")
	proto.RegisterType((*CmdPing)(nil), "protos.CmdPing")
	proto.RegisterType((*CmdPong)(nil), "protos.CmdPong")
	proto.RegisterType((*CmdHandshake)(nil), "protos.CmdHandshake")
	proto.RegisterType((*CmdHandshakeResp)(nil), "protos.CmdHandshakeResp")
	proto.RegisterType((*Cmd)(nil), "protos.Cmd")
	proto.RegisterType((*CmdResp)(nil), "protos.CmdResp")
	proto.RegisterType((*NamespacePayload)(nil), "protos.NamespacePayload")
	proto.RegisterMapType((map[string][]byte)(nil), "protos.NamespacePayload.MqEntry")
	proto.RegisterType((*CvpPayload)(nil), "protos.CvpPayload")
	proto.RegisterMapType((map[string]*NamespacePayload)(nil), "protos.CvpPayload.NsPayloadEntry")
	proto.RegisterType((*CvpConfCheck)(nil), "protos.CvpConfCheck")
	proto.RegisterMapType((map[string]*NamespaceConfCheck)(nil), "protos.CvpConfCheck.NsCheckEntry")
	proto.RegisterMapType((map[string]bool)(nil), "protos.CvpConfCheck.NsStatusEntry")
	proto.RegisterType((*NamespaceConfCheck)(nil), "protos.NamespaceConfCheck")
	proto.RegisterType((*CVPNsMsg)(nil), "protos.CVPNsMsg")
	proto.RegisterType((*BJRPing)(nil), "protos.BJRPing")
	proto.RegisterType((*BJRPong)(nil), "protos.BJRPong")
	proto.RegisterType((*VPCheckpoint)(nil), "protos.VPCheckpoint")
	proto.RegisterType((*StateNegoReq)(nil), "protos.StateNegoReq")
	proto.RegisterType((*StateNegoResp)(nil), "protos.StateNegoResp")
	proto.RegisterType((*BatchSyncRequest)(nil), "protos.BatchSyncRequest")
	proto.RegisterType((*BatchSyncResponse)(nil), "protos.BatchSyncResponse")
}

func init() { proto.RegisterFile("cvp.proto", fileDescriptor_72d8e38e08c2fc5e) }

var fileDescriptor_72d8e38e08c2fc5e = []byte{
	// 1165 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0xce, 0xf8, 0x27, 0x8e, 0xcb, 0x4e, 0x34, 0x69, 0x85, 0xc8, 0xb2, 0x76, 0xad, 0x30, 0x20,
	0x88, 0x22, 0xd6, 0x8e, 0xbc, 0x20, 0x01, 0x2b, 0x2d, 0x22, 0x26, 0x2b, 0x92, 0x25, 0x96, 0xd5,
	0x59, 0xe5, 0x00, 0xa7, 0xc9, 0x4c, 0xaf, 0x67, 0x94, 0x4c, 0xcf, 0x78, 0xba, 0x6d, 0x32, 0x42,
	0xe2, 0xc4, 0x03, 0x70, 0xe2, 0xcc, 0x89, 0x1b, 0x8f, 0xc0, 0x9d, 0xe3, 0x1e, 0x39, 0xa2, 0xe4,
	0x15, 0xb8, 0x83, 0xfa, 0x67, 0x7e, 0x6c, 0xc7, 0xec, 0xee, 0x69, 0xba, 0x6a, 0xaa, 0xbe, 0xaa,
	0xfa, 0xba, 0xba, 0xab, 0xa1, 0xee, 0xcc, 0xa2, 0x6e, 0x14, 0x87, 0x3c, 0x44, 0xeb, 0xf2, 0xc3,
	0xda, 0x5f, 0x8e, 0x7d, 0xee, 0x4d, 0x2f, 0xbb, 0x4e, 0x18, 0xf4, 0xbc, 0x24, 0x22, 0xb1, 0xe3,
	0xd9, 0x3e, 0xed, 0x8d, 0xc3, 0x47, 0x5e, 0xe4, 0x3c, 0x72, 0xc2, 0x20, 0x08, 0x69, 0x8f, 0x27,
	0x11, 0x61, 0x3d, 0xe5, 0xd1, 0x73, 0x3c, 0xe2, 0x5c, 0x45, 0xa1, 0x4f, 0xb9, 0x82, 0xb2, 0x5c,
	0xd8, 0x1a, 0xcc, 0xa2, 0x41, 0x48, 0x5f, 0x0e, 0x02, 0xf7, 0x1b, 0x9f, 0x71, 0xf4, 0x31, 0x34,
	0x9c, 0x4c, 0xc3, 0x5a, 0xc6, 0x5e, 0x79, 0xbf, 0xd1, 0x47, 0xca, 0x9c, 0x75, 0x73, 0x63, 0x5c,
	0x34, 0x43, 0x0f, 0xa0, 0x3e, 0xb4, 0x03, 0xc2, 0x22, 0xdb, 0x21, 0xad, 0xd2, 0x9e, 0xb1, 0x5f,
	0xc7, 0xb9, 0xc2, 0x1a, 0x02, 0xe4, 0x8e, 0x68, 0x17, 0xd6, 0xcf, 0x08, 0xf7, 0x42, 0xb7, 0x65,
	0x48, 0x43, 0x2d, 0x21, 0x13, 0xca, 0xcf, 0x49, 0xa2, 0xbd, 0xc5, 0x52, 0x58, 0x8e, 0xec, 0xd8,
	0x0e, 0x58, 0xab, 0xbc, 0x57, 0x16, 0x96, 0x4a, 0xb2, 0xfe, 0x30, 0xa0, 0x2e, 0x00, 0x03, 0xf7,
	0x8c, 0x8d, 0xd1, 0x21, 0x54, 0x44, 0x91, 0x12, 0x6d, 0xab, 0xff, 0xa0, 0x98, 0xaa, 0x34, 0xe8,
	0xaa, 0xcf, 0x8b, 0x24, 0x22, 0x58, 0x5a, 0xa2, 0x16, 0xd4, 0x22, 0x3b, 0xb9, 0x0e, 0x6d, 0xb7,
	0x55, 0xde, 0x33, 0xf6, 0x9b, 0x38, 0x15, 0x2d, 0x17, 0x20, 0xb7, 0x46, 0x0d, 0xa8, 0x0d, 0x02,
	0x77, 0xe4, 0xd3, 0xb1, 0xb9, 0x96, 0x0a, 0x21, 0x1d, 0x9b, 0x06, 0x32, 0xa1, 0x39, 0x08, 0xdc,
	0xaf, 0x6d, 0xea, 0x32, 0xcf, 0xbe, 0x22, 0x66, 0x09, 0xed, 0x80, 0x59, 0xd4, 0x60, 0xc2, 0x22,
	0xb3, 0x8c, 0x6a, 0x50, 0x1e, 0x04, 0xae, 0x59, 0xd1, 0xde, 0x52, 0x5b, 0xb5, 0x1e, 0x67, 0xb8,
	0x08, 0x41, 0x65, 0xe6, 0x93, 0xef, 0x65, 0xf2, 0x15, 0x2c, 0xd7, 0x68, 0x07, 0xaa, 0x4e, 0xe0,
	0x9e, 0x7c, 0x25, 0xa9, 0xa8, 0x60, 0x25, 0x58, 0x0f, 0xb3, 0xf8, 0xf7, 0x39, 0x59, 0xa3, 0xf9,
	0x8c, 0xde, 0x1c, 0x58, 0xb0, 0xec, 0x53, 0x9f, 0x13, 0x45, 0xc6, 0x06, 0xd6, 0x92, 0xf5, 0x8b,
	0xb1, 0x5c, 0x12, 0xfa, 0x28, 0xa7, 0x4e, 0x20, 0xcf, 0xb7, 0xc6, 0x48, 0xfd, 0xc9, 0xe8, 0x44,
	0x07, 0x50, 0x95, 0x2d, 0x27, 0x03, 0x36, 0xfa, 0x3b, 0x8b, 0x6d, 0x24, 0xfe, 0x61, 0x65, 0x92,
	0x27, 0x57, 0x2e, 0x26, 0x97, 0x96, 0x51, 0x29, 0x94, 0x3a, 0x91, 0xa4, 0x8a, 0x5f, 0x76, 0x3c,
	0x56, 0x2d, 0x5a, 0xc7, 0x72, 0x2d, 0x74, 0x53, 0xea, 0x86, 0xad, 0x92, 0xd2, 0x89, 0xf5, 0x0a,
	0xe0, 0x42, 0x21, 0x95, 0xd7, 0x16, 0x62, 0x3d, 0xcf, 0xb6, 0x2f, 0x87, 0x33, 0x8a, 0x70, 0x2d,
	0xa8, 0xb1, 0xa9, 0xe3, 0x10, 0xc6, 0x64, 0xad, 0x1b, 0x38, 0x15, 0x45, 0x5b, 0x07, 0x6c, 0x2c,
	0x83, 0xd7, 0xb1, 0x58, 0x5a, 0xbf, 0x1b, 0x60, 0x66, 0x87, 0x43, 0x87, 0x92, 0xb0, 0x24, 0xe6,
	0x4c, 0xc2, 0x36, 0xb1, 0x12, 0x50, 0x1b, 0x36, 0x28, 0x13, 0x54, 0xf9, 0x63, 0x89, 0xdb, 0xc4,
	0x99, 0x8c, 0x0e, 0xa1, 0x14, 0x4c, 0xe4, 0xc9, 0x68, 0xf4, 0xf7, 0xd2, 0xe4, 0x17, 0x71, 0xbb,
	0x67, 0x93, 0x63, 0xca, 0xe3, 0x04, 0x97, 0x82, 0x49, 0xfb, 0x13, 0xa8, 0x69, 0x51, 0x64, 0x75,
	0x45, 0x12, 0x7d, 0x02, 0xc5, 0x52, 0x24, 0x30, 0xb3, 0xaf, 0xa7, 0x44, 0xc7, 0x51, 0xc2, 0xe7,
	0xa5, 0x4f, 0x0d, 0xeb, 0x5f, 0x43, 0x9e, 0xdf, 0x34, 0x53, 0x51, 0x6a, 0x22, 0x93, 0xd0, 0xb9,
	0xa6, 0x22, 0xfa, 0x02, 0xea, 0x94, 0x69, 0x33, 0xb9, 0x05, 0x8d, 0xfe, 0xbb, 0xcb, 0xac, 0x76,
	0x87, 0xa9, 0x8d, 0xca, 0x2c, 0xf7, 0x41, 0x4f, 0x61, 0xcb, 0x99, 0xbb, 0x8e, 0x24, 0x6d, 0x8d,
	0xfe, 0xee, 0xf2, 0xfd, 0x23, 0xfe, 0xe2, 0x05, 0xeb, 0xf6, 0x05, 0x6c, 0xcd, 0x83, 0xdf, 0x53,
	0x67, 0xb7, 0x58, 0x67, 0xa3, 0xdf, 0x5a, 0xc5, 0x5c, 0x91, 0x81, 0x5f, 0x4b, 0xd0, 0x2c, 0xf6,
	0x2c, 0x7a, 0x2a, 0xf6, 0xe5, 0x9c, 0xdb, 0x7c, 0x9a, 0x5e, 0x91, 0xd6, 0x7d, 0xbd, 0xdd, 0x1d,
	0x6a, 0x23, 0x55, 0x69, 0xe6, 0x83, 0x9e, 0x40, 0x8d, 0xb2, 0x81, 0x3e, 0x1a, 0x8b, 0x3c, 0x15,
	0xdd, 0xe5, 0x57, 0x79, 0xa7, 0x1e, 0xed, 0x27, 0xb0, 0x39, 0x87, 0xfb, 0xba, 0xcd, 0xdc, 0x28,
	0x94, 0xd2, 0xbe, 0x80, 0x66, 0x11, 0xf5, 0x1e, 0xdf, 0xc3, 0x79, 0x82, 0xda, 0x4b, 0x04, 0x15,
	0x8e, 0x6e, 0x4e, 0xd1, 0x0c, 0xd0, 0xb2, 0x01, 0x7a, 0x1f, 0x36, 0x09, 0x75, 0xe2, 0x24, 0xe2,
	0x47, 0x3e, 0x0f, 0xec, 0x48, 0xc6, 0xd9, 0xc4, 0xf3, 0x4a, 0x64, 0x41, 0xd3, 0xa7, 0x2e, 0xb9,
	0x39, 0xa6, 0xf6, 0xe5, 0x35, 0x71, 0x75, 0xd2, 0x73, 0x3a, 0x71, 0x4b, 0x5d, 0xdb, 0x09, 0x89,
	0xfb, 0xfa, 0xca, 0xd6, 0x92, 0xf5, 0x8f, 0x01, 0x1b, 0x83, 0x8b, 0xd1, 0x90, 0x89, 0x51, 0xb0,
	0x0b, 0xeb, 0x94, 0x89, 0x34, 0xd2, 0xd1, 0xa2, 0x24, 0xd4, 0x83, 0x32, 0x4f, 0x22, 0x89, 0xbb,
	0xd5, 0x7f, 0x98, 0x51, 0xad, 0xdd, 0xb2, 0x85, 0x1c, 0x11, 0xc2, 0xf2, 0x7f, 0x26, 0xc4, 0x4f,
	0x06, 0x34, 0x8b, 0xf6, 0xe2, 0x66, 0x3f, 0x3a, 0xc5, 0xf9, 0x90, 0x10, 0x42, 0x36, 0x24, 0x2e,
	0x46, 0x83, 0x6c, 0xe4, 0x9a, 0x25, 0xa1, 0x11, 0xfb, 0x46, 0x86, 0x64, 0x1c, 0x62, 0x32, 0x31,
	0xcb, 0x68, 0x1b, 0x36, 0x0b, 0x1a, 0x16, 0x99, 0x15, 0x61, 0xf4, 0x8c, 0x70, 0xc7, 0xc3, 0x64,
	0x32, 0x25, 0x8c, 0x9b, 0x55, 0x61, 0xa4, 0x35, 0x2c, 0x0a, 0x29, 0x23, 0xe6, 0xba, 0xf5, 0x59,
	0x16, 0x55, 0x14, 0xed, 0x11, 0x7f, 0xec, 0x71, 0x7d, 0x23, 0x69, 0x49, 0xe8, 0x19, 0xa1, 0x2e,
	0x89, 0xf5, 0x48, 0xd5, 0x92, 0xf5, 0x5d, 0x96, 0xe3, 0x4a, 0xd7, 0x16, 0xd4, 0xc6, 0x84, 0x12,
	0xe6, 0x33, 0x3d, 0x2a, 0x52, 0x11, 0x75, 0x00, 0x18, 0xb5, 0x23, 0xe6, 0x85, 0x5c, 0xdf, 0xa8,
	0x75, 0x5c, 0xd0, 0x58, 0x1f, 0xcc, 0xd7, 0xbc, 0x2a, 0x82, 0xf5, 0x6c, 0x9e, 0x89, 0x05, 0x5c,
	0x63, 0x11, 0x77, 0x65, 0x31, 0xbf, 0x19, 0x0b, 0x04, 0x8a, 0x2b, 0x93, 0x79, 0x76, 0xec, 0x0e,
	0xa7, 0x81, 0x8e, 0x99, 0xc9, 0xe2, 0x99, 0x22, 0x30, 0x5f, 0xdc, 0x9c, 0x4f, 0x03, 0x5d, 0x59,
	0xae, 0x40, 0x3d, 0xa8, 0x93, 0x28, 0x74, 0xbc, 0x13, 0xfa, 0x32, 0xd4, 0x17, 0xcf, 0x76, 0xda,
	0x2b, 0xc7, 0xe9, 0x0f, 0x9c, 0xdb, 0xa0, 0x03, 0x30, 0x85, 0xf7, 0x09, 0x9d, 0xd9, 0xd7, 0xbe,
	0xab, 0x50, 0xd5, 0xa0, 0x5a, 0xd2, 0x5b, 0x3f, 0x80, 0x79, 0x64, 0x73, 0xc7, 0x3b, 0x4f, 0xa8,
	0xa3, 0x77, 0x16, 0x7d, 0xa8, 0xda, 0x52, 0x3d, 0x5c, 0xde, 0x49, 0x43, 0x65, 0x66, 0x79, 0x3b,
	0xee, 0x40, 0x95, 0x71, 0x3b, 0xe6, 0xe9, 0xe0, 0x96, 0x82, 0x38, 0xba, 0x84, 0xba, 0x7a, 0xac,
	0x89, 0xa5, 0x60, 0xe9, 0x5c, 0xb1, 0x54, 0x51, 0x2c, 0x29, 0xc9, 0xfa, 0x11, 0xb6, 0x0b, 0xc1,
	0x55, 0x13, 0xbd, 0x79, 0x74, 0x13, 0xca, 0x34, 0xe3, 0x4b, 0x2c, 0x57, 0x1f, 0x0f, 0x91, 0x29,
	0xb9, 0xe1, 0xb1, 0x2d, 0x13, 0x68, 0x62, 0x25, 0x1c, 0xbc, 0x07, 0x9b, 0x73, 0xb8, 0xe2, 0x5d,
	0x74, 0x74, 0x8a, 0xcd, 0x35, 0x54, 0x87, 0xaa, 0xdc, 0x3e, 0xd3, 0x38, 0x3a, 0xfd, 0xf3, 0xb6,
	0x63, 0xbc, 0xba, 0xed, 0x18, 0x7f, 0xdf, 0x76, 0x8c, 0x9f, 0xef, 0x3a, 0x6b, 0xaf, 0xee, 0x3a,
	0x6b, 0x7f, 0xdd, 0x75, 0xd6, 0xbe, 0x3d, 0x7c, 0xdb, 0x87, 0xee, 0xa5, 0x7a, 0x22, 0x3f, 0xfe,
	0x2f, 0x00, 0x00, 0xff, 0xff, 0x71, 0x4d, 0x51, 0xfb, 0x36, 0x0b, 0x00, 0x00,
}

func (m *CvpConfCmdList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CvpConfCmdList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CvpConfCmdList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CvpConfCmds) > 0 {
		for iNdEx := len(m.CvpConfCmds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CvpConfCmds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCvp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CvpConfCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CvpConfCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CvpConfCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Params) > 0 {
		for iNdEx := len(m.Params) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Params[iNdEx])
			copy(dAtA[i:], m.Params[iNdEx])
			i = encodeVarintCvp(dAtA, i, uint64(len(m.Params[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CvpCmdMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CvpCmdMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CvpCmdMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CmdPing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CmdPing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CmdPing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CmdID != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.CmdID))
		i--
		dAtA[i] = 0x10
	}
	if m.View != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CmdPong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CmdPong) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CmdPong) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.View != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CmdHandshake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CmdHandshake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CmdHandshake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Inited {
		i--
		if m.Inited {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.CmdID != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.CmdID))
		i--
		dAtA[i] = 0x10
	}
	if m.View != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CmdHandshakeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CmdHandshakeResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CmdHandshakeResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.View != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x20
	}
	if m.CmdID != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.CmdID))
		i--
		dAtA[i] = 0x18
	}
	if m.Check != nil {
		{
			size, err := m.Check.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCvp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCvp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCvp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CmdID != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.CmdID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Undo) > 0 {
		for iNdEx := len(m.Undo) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Undo[iNdEx])
			copy(dAtA[i:], m.Undo[iNdEx])
			i = encodeVarintCvp(dAtA, i, uint64(len(m.Undo[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintCvp(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CmdResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CmdResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CmdResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.CmdID != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.CmdID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NamespacePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespacePayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespacePayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Mq) > 0 {
		for k := range m.Mq {
			v := m.Mq[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintCvp(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCvp(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCvp(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.NsConfig) > 0 {
		i -= len(m.NsConfig)
		copy(dAtA[i:], m.NsConfig)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.NsConfig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Certs) > 0 {
		i -= len(m.Certs)
		copy(dAtA[i:], m.Certs)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.Certs)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CvpPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CvpPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CvpPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CvpConfCmdList != nil {
		{
			size, err := m.CvpConfCmdList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCvp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NsPayload) > 0 {
		for k := range m.NsPayload {
			v := m.NsPayload[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCvp(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCvp(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCvp(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SysConf) > 0 {
		i -= len(m.SysConf)
		copy(dAtA[i:], m.SysConf)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.SysConf)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CvpConfCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CvpConfCheck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CvpConfCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NsCheck) > 0 {
		for k := range m.NsCheck {
			v := m.NsCheck[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCvp(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCvp(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCvp(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NsStatus) > 0 {
		for k := range m.NsStatus {
			v := m.NsStatus[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCvp(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCvp(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceConfCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceConfCheck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceConfCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Layer2) > 0 {
		i -= len(m.Layer2)
		copy(dAtA[i:], m.Layer2)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.Layer2)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexEnabled {
		i--
		if m.IndexEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.EncryptBitmap != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.EncryptBitmap))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CVPNsMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CVPNsMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CVPNsMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Typ != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NsName) > 0 {
		i -= len(m.NsName)
		copy(dAtA[i:], m.NsName)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.NsName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BJRPing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BJRPing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BJRPing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if m.Height != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BJRPong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BJRPong) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BJRPong) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SnapshotID) > 0 {
		i -= len(m.SnapshotID)
		copy(dAtA[i:], m.SnapshotID)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.SnapshotID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Genesis != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.Genesis))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VPCheckpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCheckpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCheckpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateNegoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateNegoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateNegoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SnapshotID) > 0 {
		i -= len(m.SnapshotID)
		copy(dAtA[i:], m.SnapshotID)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.SnapshotID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StateNegoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateNegoResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateNegoResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SnapInvalidTxSum != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.SnapInvalidTxSum))
		i--
		dAtA[i] = 0x20
	}
	if m.EpochInfo != nil {
		{
			size, err := m.EpochInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCvp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SnapTxSum != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.SnapTxSum))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardNum != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.ShardNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchSyncRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSyncRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSyncRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x22
	}
	if m.End != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if m.Typ != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchSyncResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSyncResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSyncResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extra) > 0 {
		i -= len(m.Extra)
		copy(dAtA[i:], m.Extra)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.Extra)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintCvp(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Num != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x10
	}
	if m.Typ != 0 {
		i = encodeVarintCvp(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCvp(dAtA []byte, offset int, v uint64) int {
	offset -= sovCvp(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CvpConfCmdList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CvpConfCmds) > 0 {
		for _, e := range m.CvpConfCmds {
			l = e.Size()
			n += 1 + l + sovCvp(uint64(l))
		}
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	return n
}

func (m *CvpConfCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	if len(m.Params) > 0 {
		for _, s := range m.Params {
			l = len(s)
			n += 1 + l + sovCvp(uint64(l))
		}
	}
	return n
}

func (m *CvpCmdMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCvp(uint64(m.Type))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	return n
}

func (m *CmdPing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != 0 {
		n += 1 + sovCvp(uint64(m.View))
	}
	if m.CmdID != 0 {
		n += 1 + sovCvp(uint64(m.CmdID))
	}
	return n
}

func (m *CmdPong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != 0 {
		n += 1 + sovCvp(uint64(m.View))
	}
	return n
}

func (m *CmdHandshake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != 0 {
		n += 1 + sovCvp(uint64(m.View))
	}
	if m.CmdID != 0 {
		n += 1 + sovCvp(uint64(m.CmdID))
	}
	if m.Inited {
		n += 2
	}
	return n
}

func (m *CmdHandshakeResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovCvp(uint64(l))
	}
	if m.Check != nil {
		l = m.Check.Size()
		n += 1 + l + sovCvp(uint64(l))
	}
	if m.CmdID != 0 {
		n += 1 + sovCvp(uint64(m.CmdID))
	}
	if m.View != 0 {
		n += 1 + sovCvp(uint64(m.View))
	}
	return n
}

func (m *Cmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovCvp(uint64(l))
		}
	}
	if len(m.Undo) > 0 {
		for _, s := range m.Undo {
			l = len(s)
			n += 1 + l + sovCvp(uint64(l))
		}
	}
	if m.CmdID != 0 {
		n += 1 + sovCvp(uint64(m.CmdID))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovCvp(uint64(l))
	}
	return n
}

func (m *CmdResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdID != 0 {
		n += 1 + sovCvp(uint64(m.CmdID))
	}
	if m.Success {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	return n
}

func (m *NamespacePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Certs)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	l = len(m.NsConfig)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	if len(m.Mq) > 0 {
		for k, v := range m.Mq {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovCvp(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovCvp(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCvp(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CvpPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SysConf)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	if len(m.NsPayload) > 0 {
		for k, v := range m.NsPayload {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCvp(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCvp(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCvp(uint64(mapEntrySize))
		}
	}
	if m.CvpConfCmdList != nil {
		l = m.CvpConfCmdList.Size()
		n += 1 + l + sovCvp(uint64(l))
	}
	return n
}

func (m *CvpConfCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NsStatus) > 0 {
		for k, v := range m.NsStatus {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCvp(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 1 + sovCvp(uint64(mapEntrySize))
		}
	}
	if len(m.NsCheck) > 0 {
		for k, v := range m.NsCheck {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCvp(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCvp(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCvp(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NamespaceConfCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EncryptBitmap != 0 {
		n += 1 + sovCvp(uint64(m.EncryptBitmap))
	}
	if m.IndexEnabled {
		n += 2
	}
	l = len(m.Layer2)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	return n
}

func (m *CVPNsMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NsName)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	if m.Typ != 0 {
		n += 1 + sovCvp(uint64(m.Typ))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	return n
}

func (m *BJRPing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovCvp(uint64(m.Height))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	return n
}

func (m *BJRPong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovCvp(uint64(m.Height))
	}
	if m.Genesis != 0 {
		n += 1 + sovCvp(uint64(m.Genesis))
	}
	l = len(m.SnapshotID)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	return n
}

func (m *VPCheckpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovCvp(uint64(m.Height))
	}
	return n
}

func (m *StateNegoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SnapshotID)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	return n
}

func (m *StateNegoResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardNum != 0 {
		n += 1 + sovCvp(uint64(m.ShardNum))
	}
	if m.SnapTxSum != 0 {
		n += 1 + sovCvp(uint64(m.SnapTxSum))
	}
	if m.EpochInfo != nil {
		l = m.EpochInfo.Size()
		n += 1 + l + sovCvp(uint64(l))
	}
	if m.SnapInvalidTxSum != 0 {
		n += 1 + sovCvp(uint64(m.SnapInvalidTxSum))
	}
	return n
}

func (m *BatchSyncRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovCvp(uint64(m.Typ))
	}
	if m.Start != 0 {
		n += 1 + sovCvp(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovCvp(uint64(m.End))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	return n
}

func (m *BatchSyncResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovCvp(uint64(m.Typ))
	}
	if m.Num != 0 {
		n += 1 + sovCvp(uint64(m.Num))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	l = len(m.Extra)
	if l > 0 {
		n += 1 + l + sovCvp(uint64(l))
	}
	return n
}

func sovCvp(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCvp(x uint64) (n int) {
	return sovCvp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CvpConfCmdList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CvpConfCmdList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CvpConfCmdList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvpConfCmds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CvpConfCmds = append(m.CvpConfCmds, &CvpConfCmd{})
			if err := m.CvpConfCmds[len(m.CvpConfCmds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CvpConfCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CvpConfCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CvpConfCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CvpCmdMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CvpCmdMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CvpCmdMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CvpCmdMsg_CmdMsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CmdPing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CmdPing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CmdPing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdID", wireType)
			}
			m.CmdID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CmdPong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CmdPong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CmdPong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CmdHandshake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CmdHandshake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CmdHandshake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdID", wireType)
			}
			m.CmdID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inited = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CmdHandshakeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CmdHandshakeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CmdHandshakeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &CvpPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Check == nil {
				m.Check = &CvpConfCheck{}
			}
			if err := m.Check.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdID", wireType)
			}
			m.CmdID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Undo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Undo = append(m.Undo, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdID", wireType)
			}
			m.CmdID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &CvpPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CmdResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CmdResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CmdResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdID", wireType)
			}
			m.CmdID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespacePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespacePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespacePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certs = append(m.Certs[:0], dAtA[iNdEx:postIndex]...)
			if m.Certs == nil {
				m.Certs = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsConfig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NsConfig = append(m.NsConfig[:0], dAtA[iNdEx:postIndex]...)
			if m.NsConfig == nil {
				m.NsConfig = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mq == nil {
				m.Mq = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCvp
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCvp
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthCvp
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthCvp
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCvp(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCvp
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Mq[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CvpPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CvpPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CvpPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysConf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysConf = append(m.SysConf[:0], dAtA[iNdEx:postIndex]...)
			if m.SysConf == nil {
				m.SysConf = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NsPayload == nil {
				m.NsPayload = make(map[string]*NamespacePayload)
			}
			var mapkey string
			var mapvalue *NamespacePayload
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCvp
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCvp
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCvp
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCvp
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NamespacePayload{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCvp(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCvp
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NsPayload[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvpConfCmdList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CvpConfCmdList == nil {
				m.CvpConfCmdList = &CvpConfCmdList{}
			}
			if err := m.CvpConfCmdList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CvpConfCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CvpConfCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CvpConfCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NsStatus == nil {
				m.NsStatus = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCvp
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCvp
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCvp(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCvp
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NsStatus[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NsCheck == nil {
				m.NsCheck = make(map[string]*NamespaceConfCheck)
			}
			var mapkey string
			var mapvalue *NamespaceConfCheck
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCvp
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCvp
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCvp
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCvp
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NamespaceConfCheck{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCvp(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCvp
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NsCheck[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceConfCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceConfCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceConfCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptBitmap", wireType)
			}
			m.EncryptBitmap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncryptBitmap |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IndexEnabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layer2 = append(m.Layer2[:0], dAtA[iNdEx:postIndex]...)
			if m.Layer2 == nil {
				m.Layer2 = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CVPNsMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CVPNsMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CVPNsMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= CVPNsMsg_CVPNsMsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BJRPing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BJRPing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BJRPing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BJRPong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BJRPong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BJRPong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			m.Genesis = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Genesis |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCheckpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCheckpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCheckpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateNegoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateNegoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateNegoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateNegoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateNegoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateNegoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardNum", wireType)
			}
			m.ShardNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapTxSum", wireType)
			}
			m.SnapTxSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapTxSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EpochInfo == nil {
				m.EpochInfo = &EpochInfo{}
			}
			if err := m.EpochInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapInvalidTxSum", wireType)
			}
			m.SnapInvalidTxSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapInvalidTxSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSyncRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSyncRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSyncRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= BatchSyncType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSyncResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSyncResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSyncResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= BatchSyncType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCvp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCvp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extra = append(m.Extra[:0], dAtA[iNdEx:postIndex]...)
			if m.Extra == nil {
				m.Extra = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCvp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCvp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCvp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCvp
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCvp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCvp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCvp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCvp
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCvp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCvp   = fmt.Errorf("proto: integer overflow")
)
